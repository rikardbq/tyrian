Compiled from "IntPipeline.java"
abstract class java.util.stream.IntPipeline<E_IN> extends java.util.stream.AbstractPipeline<E_IN, java.lang.Integer, java.util.stream.IntStream> implements java.util.stream.IntStream {
  java.util.stream.IntPipeline(java.util.function.Supplier<? extends java.util.Spliterator<java.lang.Integer>>, int, boolean);
  java.util.stream.IntPipeline(java.util.Spliterator<java.lang.Integer>, int, boolean);
  java.util.stream.IntPipeline(java.util.stream.AbstractPipeline<?, E_IN, ?>, int);
  final java.util.stream.StreamShape getOutputShape();
  final <P_IN> java.util.stream.Node<java.lang.Integer> evaluateToNode(java.util.stream.PipelineHelper<java.lang.Integer>, java.util.Spliterator<P_IN>, boolean, java.util.function.IntFunction<java.lang.Integer[]>);
  final <P_IN> java.util.Spliterator<java.lang.Integer> wrap(java.util.stream.PipelineHelper<java.lang.Integer>, java.util.function.Supplier<java.util.Spliterator<P_IN>>, boolean);
  final java.util.Spliterator$OfInt lazySpliterator(java.util.function.Supplier<? extends java.util.Spliterator<java.lang.Integer>>);
  final boolean forEachWithCancel(java.util.Spliterator<java.lang.Integer>, java.util.stream.Sink<java.lang.Integer>);
  final java.util.stream.Node$Builder<java.lang.Integer> makeNodeBuilder(long, java.util.function.IntFunction<java.lang.Integer[]>);
  public final java.util.PrimitiveIterator$OfInt iterator();
  public final java.util.Spliterator$OfInt spliterator();
  public final java.util.stream.LongStream asLongStream();
  public final java.util.stream.DoubleStream asDoubleStream();
  public final java.util.stream.Stream<java.lang.Integer> boxed();
  public final java.util.stream.IntStream map(java.util.function.IntUnaryOperator);
  public final <U> java.util.stream.Stream<U> mapToObj(java.util.function.IntFunction<? extends U>);
  public final java.util.stream.LongStream mapToLong(java.util.function.IntToLongFunction);
  public final java.util.stream.DoubleStream mapToDouble(java.util.function.IntToDoubleFunction);
  public final java.util.stream.IntStream flatMap(java.util.function.IntFunction<? extends java.util.stream.IntStream>);
  public java.util.stream.IntStream unordered();
  public final java.util.stream.IntStream filter(java.util.function.IntPredicate);
  public final java.util.stream.IntStream peek(java.util.function.IntConsumer);
  public final java.util.stream.IntStream limit(long);
  public final java.util.stream.IntStream skip(long);
  public final java.util.stream.IntStream takeWhile(java.util.function.IntPredicate);
  public final java.util.stream.IntStream dropWhile(java.util.function.IntPredicate);
  public final java.util.stream.IntStream sorted();
  public final java.util.stream.IntStream distinct();
  public void forEach(java.util.function.IntConsumer);
  public void forEachOrdered(java.util.function.IntConsumer);
  public final int sum();
  public final java.util.OptionalInt min();
  public final java.util.OptionalInt max();
  public final long count();
  public final java.util.OptionalDouble average();
  public final java.util.IntSummaryStatistics summaryStatistics();
  public final int reduce(int, java.util.function.IntBinaryOperator);
  public final java.util.OptionalInt reduce(java.util.function.IntBinaryOperator);
  public final <R> R collect(java.util.function.Supplier<R>, java.util.function.ObjIntConsumer<R>, java.util.function.BiConsumer<R, R>);
  public final boolean anyMatch(java.util.function.IntPredicate);
  public final boolean allMatch(java.util.function.IntPredicate);
  public final boolean noneMatch(java.util.function.IntPredicate);
  public final java.util.OptionalInt findFirst();
  public final java.util.OptionalInt findAny();
  public final int[] toArray();
  java.util.Spliterator lazySpliterator(java.util.function.Supplier);
  public java.util.Spliterator spliterator();
  public java.util.stream.BaseStream unordered();
  public java.util.Iterator iterator();
  public java.util.stream.IntStream parallel();
  public java.util.stream.IntStream sequential();
}
