Compiled from "ReferencePipeline.java"
abstract class java.util.stream.ReferencePipeline<P_IN, P_OUT> extends java.util.stream.AbstractPipeline<P_IN, P_OUT, java.util.stream.Stream<P_OUT>> implements java.util.stream.Stream<P_OUT> {
  java.util.stream.ReferencePipeline(java.util.function.Supplier<? extends java.util.Spliterator<?>>, int, boolean);
  java.util.stream.ReferencePipeline(java.util.Spliterator<?>, int, boolean);
  java.util.stream.ReferencePipeline(java.util.stream.AbstractPipeline<?, P_IN, ?>, int);
  final java.util.stream.StreamShape getOutputShape();
  final <P_IN> java.util.stream.Node<P_OUT> evaluateToNode(java.util.stream.PipelineHelper<P_OUT>, java.util.Spliterator<P_IN>, boolean, java.util.function.IntFunction<P_OUT[]>);
  final <P_IN> java.util.Spliterator<P_OUT> wrap(java.util.stream.PipelineHelper<P_OUT>, java.util.function.Supplier<java.util.Spliterator<P_IN>>, boolean);
  final java.util.Spliterator<P_OUT> lazySpliterator(java.util.function.Supplier<? extends java.util.Spliterator<P_OUT>>);
  final boolean forEachWithCancel(java.util.Spliterator<P_OUT>, java.util.stream.Sink<P_OUT>);
  final java.util.stream.Node$Builder<P_OUT> makeNodeBuilder(long, java.util.function.IntFunction<P_OUT[]>);
  public final java.util.Iterator<P_OUT> iterator();
  public java.util.stream.Stream<P_OUT> unordered();
  public final java.util.stream.Stream<P_OUT> filter(java.util.function.Predicate<? super P_OUT>);
  public final <R> java.util.stream.Stream<R> map(java.util.function.Function<? super P_OUT, ? extends R>);
  public final java.util.stream.IntStream mapToInt(java.util.function.ToIntFunction<? super P_OUT>);
  public final java.util.stream.LongStream mapToLong(java.util.function.ToLongFunction<? super P_OUT>);
  public final java.util.stream.DoubleStream mapToDouble(java.util.function.ToDoubleFunction<? super P_OUT>);
  public final <R> java.util.stream.Stream<R> flatMap(java.util.function.Function<? super P_OUT, ? extends java.util.stream.Stream<? extends R>>);
  public final java.util.stream.IntStream flatMapToInt(java.util.function.Function<? super P_OUT, ? extends java.util.stream.IntStream>);
  public final java.util.stream.DoubleStream flatMapToDouble(java.util.function.Function<? super P_OUT, ? extends java.util.stream.DoubleStream>);
  public final java.util.stream.LongStream flatMapToLong(java.util.function.Function<? super P_OUT, ? extends java.util.stream.LongStream>);
  public final java.util.stream.Stream<P_OUT> peek(java.util.function.Consumer<? super P_OUT>);
  public final java.util.stream.Stream<P_OUT> distinct();
  public final java.util.stream.Stream<P_OUT> sorted();
  public final java.util.stream.Stream<P_OUT> sorted(java.util.Comparator<? super P_OUT>);
  public final java.util.stream.Stream<P_OUT> limit(long);
  public final java.util.stream.Stream<P_OUT> skip(long);
  public final java.util.stream.Stream<P_OUT> takeWhile(java.util.function.Predicate<? super P_OUT>);
  public final java.util.stream.Stream<P_OUT> dropWhile(java.util.function.Predicate<? super P_OUT>);
  public void forEach(java.util.function.Consumer<? super P_OUT>);
  public void forEachOrdered(java.util.function.Consumer<? super P_OUT>);
  public final <A> A[] toArray(java.util.function.IntFunction<A[]>);
  public final java.lang.Object[] toArray();
  public final boolean anyMatch(java.util.function.Predicate<? super P_OUT>);
  public final boolean allMatch(java.util.function.Predicate<? super P_OUT>);
  public final boolean noneMatch(java.util.function.Predicate<? super P_OUT>);
  public final java.util.Optional<P_OUT> findFirst();
  public final java.util.Optional<P_OUT> findAny();
  public final P_OUT reduce(P_OUT, java.util.function.BinaryOperator<P_OUT>);
  public final java.util.Optional<P_OUT> reduce(java.util.function.BinaryOperator<P_OUT>);
  public final <R> R reduce(R, java.util.function.BiFunction<R, ? super P_OUT, R>, java.util.function.BinaryOperator<R>);
  public final <R, A> R collect(java.util.stream.Collector<? super P_OUT, A, R>);
  public final <R> R collect(java.util.function.Supplier<R>, java.util.function.BiConsumer<R, ? super P_OUT>, java.util.function.BiConsumer<R, R>);
  public final java.util.Optional<P_OUT> max(java.util.Comparator<? super P_OUT>);
  public final java.util.Optional<P_OUT> min(java.util.Comparator<? super P_OUT>);
  public final long count();
  public java.util.stream.BaseStream unordered();
}
