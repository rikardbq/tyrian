Compiled from "DoubleStream.java"
public interface java.util.stream.DoubleStream extends java.util.stream.BaseStream<java.lang.Double, java.util.stream.DoubleStream> {
  public abstract java.util.stream.DoubleStream filter(java.util.function.DoublePredicate);
  public abstract java.util.stream.DoubleStream map(java.util.function.DoubleUnaryOperator);
  public abstract <U> java.util.stream.Stream<U> mapToObj(java.util.function.DoubleFunction<? extends U>);
  public abstract java.util.stream.IntStream mapToInt(java.util.function.DoubleToIntFunction);
  public abstract java.util.stream.LongStream mapToLong(java.util.function.DoubleToLongFunction);
  public abstract java.util.stream.DoubleStream flatMap(java.util.function.DoubleFunction<? extends java.util.stream.DoubleStream>);
  public abstract java.util.stream.DoubleStream distinct();
  public abstract java.util.stream.DoubleStream sorted();
  public abstract java.util.stream.DoubleStream peek(java.util.function.DoubleConsumer);
  public abstract java.util.stream.DoubleStream limit(long);
  public abstract java.util.stream.DoubleStream skip(long);
  public default java.util.stream.DoubleStream takeWhile(java.util.function.DoublePredicate);
  public default java.util.stream.DoubleStream dropWhile(java.util.function.DoublePredicate);
  public abstract void forEach(java.util.function.DoubleConsumer);
  public abstract void forEachOrdered(java.util.function.DoubleConsumer);
  public abstract double[] toArray();
  public abstract double reduce(double, java.util.function.DoubleBinaryOperator);
  public abstract java.util.OptionalDouble reduce(java.util.function.DoubleBinaryOperator);
  public abstract <R> R collect(java.util.function.Supplier<R>, java.util.function.ObjDoubleConsumer<R>, java.util.function.BiConsumer<R, R>);
  public abstract double sum();
  public abstract java.util.OptionalDouble min();
  public abstract java.util.OptionalDouble max();
  public abstract long count();
  public abstract java.util.OptionalDouble average();
  public abstract java.util.DoubleSummaryStatistics summaryStatistics();
  public abstract boolean anyMatch(java.util.function.DoublePredicate);
  public abstract boolean allMatch(java.util.function.DoublePredicate);
  public abstract boolean noneMatch(java.util.function.DoublePredicate);
  public abstract java.util.OptionalDouble findFirst();
  public abstract java.util.OptionalDouble findAny();
  public abstract java.util.stream.Stream<java.lang.Double> boxed();
  public abstract java.util.stream.DoubleStream sequential();
  public abstract java.util.stream.DoubleStream parallel();
  public abstract java.util.PrimitiveIterator$OfDouble iterator();
  public abstract java.util.Spliterator$OfDouble spliterator();
  public static java.util.stream.DoubleStream$Builder builder();
  public static java.util.stream.DoubleStream empty();
  public static java.util.stream.DoubleStream of(double);
  public static java.util.stream.DoubleStream of(double...);
  public static java.util.stream.DoubleStream iterate(double, java.util.function.DoubleUnaryOperator);
  public static java.util.stream.DoubleStream iterate(double, java.util.function.DoublePredicate, java.util.function.DoubleUnaryOperator);
  public static java.util.stream.DoubleStream generate(java.util.function.DoubleSupplier);
  public static java.util.stream.DoubleStream concat(java.util.stream.DoubleStream, java.util.stream.DoubleStream);
  public default java.util.stream.BaseStream parallel();
  public default java.util.stream.BaseStream sequential();
  public default java.util.Spliterator spliterator();
  public default java.util.Iterator iterator();
}
