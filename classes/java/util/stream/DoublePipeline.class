Compiled from "DoublePipeline.java"
abstract class java.util.stream.DoublePipeline<E_IN> extends java.util.stream.AbstractPipeline<E_IN, java.lang.Double, java.util.stream.DoubleStream> implements java.util.stream.DoubleStream {
  java.util.stream.DoublePipeline(java.util.function.Supplier<? extends java.util.Spliterator<java.lang.Double>>, int, boolean);
  java.util.stream.DoublePipeline(java.util.Spliterator<java.lang.Double>, int, boolean);
  java.util.stream.DoublePipeline(java.util.stream.AbstractPipeline<?, E_IN, ?>, int);
  final java.util.stream.StreamShape getOutputShape();
  final <P_IN> java.util.stream.Node<java.lang.Double> evaluateToNode(java.util.stream.PipelineHelper<java.lang.Double>, java.util.Spliterator<P_IN>, boolean, java.util.function.IntFunction<java.lang.Double[]>);
  final <P_IN> java.util.Spliterator<java.lang.Double> wrap(java.util.stream.PipelineHelper<java.lang.Double>, java.util.function.Supplier<java.util.Spliterator<P_IN>>, boolean);
  final java.util.Spliterator$OfDouble lazySpliterator(java.util.function.Supplier<? extends java.util.Spliterator<java.lang.Double>>);
  final boolean forEachWithCancel(java.util.Spliterator<java.lang.Double>, java.util.stream.Sink<java.lang.Double>);
  final java.util.stream.Node$Builder<java.lang.Double> makeNodeBuilder(long, java.util.function.IntFunction<java.lang.Double[]>);
  public final java.util.PrimitiveIterator$OfDouble iterator();
  public final java.util.Spliterator$OfDouble spliterator();
  public final java.util.stream.Stream<java.lang.Double> boxed();
  public final java.util.stream.DoubleStream map(java.util.function.DoubleUnaryOperator);
  public final <U> java.util.stream.Stream<U> mapToObj(java.util.function.DoubleFunction<? extends U>);
  public final java.util.stream.IntStream mapToInt(java.util.function.DoubleToIntFunction);
  public final java.util.stream.LongStream mapToLong(java.util.function.DoubleToLongFunction);
  public final java.util.stream.DoubleStream flatMap(java.util.function.DoubleFunction<? extends java.util.stream.DoubleStream>);
  public java.util.stream.DoubleStream unordered();
  public final java.util.stream.DoubleStream filter(java.util.function.DoublePredicate);
  public final java.util.stream.DoubleStream peek(java.util.function.DoubleConsumer);
  public final java.util.stream.DoubleStream limit(long);
  public final java.util.stream.DoubleStream skip(long);
  public final java.util.stream.DoubleStream takeWhile(java.util.function.DoublePredicate);
  public final java.util.stream.DoubleStream dropWhile(java.util.function.DoublePredicate);
  public final java.util.stream.DoubleStream sorted();
  public final java.util.stream.DoubleStream distinct();
  public void forEach(java.util.function.DoubleConsumer);
  public void forEachOrdered(java.util.function.DoubleConsumer);
  public final double sum();
  public final java.util.OptionalDouble min();
  public final java.util.OptionalDouble max();
  public final java.util.OptionalDouble average();
  public final long count();
  public final java.util.DoubleSummaryStatistics summaryStatistics();
  public final double reduce(double, java.util.function.DoubleBinaryOperator);
  public final java.util.OptionalDouble reduce(java.util.function.DoubleBinaryOperator);
  public final <R> R collect(java.util.function.Supplier<R>, java.util.function.ObjDoubleConsumer<R>, java.util.function.BiConsumer<R, R>);
  public final boolean anyMatch(java.util.function.DoublePredicate);
  public final boolean allMatch(java.util.function.DoublePredicate);
  public final boolean noneMatch(java.util.function.DoublePredicate);
  public final java.util.OptionalDouble findFirst();
  public final java.util.OptionalDouble findAny();
  public final double[] toArray();
  java.util.Spliterator lazySpliterator(java.util.function.Supplier);
  public java.util.Spliterator spliterator();
  public java.util.stream.BaseStream unordered();
  public java.util.Iterator iterator();
  public java.util.stream.DoubleStream parallel();
  public java.util.stream.DoubleStream sequential();
}
