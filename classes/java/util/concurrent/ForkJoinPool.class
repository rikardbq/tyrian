Compiled from "ForkJoinPool.java"
public class java.util.concurrent.ForkJoinPool extends java.util.concurrent.AbstractExecutorService {
  static final int SWIDTH;
  static final int SMASK;
  static final int MAX_CAP;
  static final int SQMASK;
  static final int UNSIGNALLED;
  static final int SS_SEQ;
  static final int QLOCK;
  static final int OWNED;
  static final int FIFO;
  static final int SHUTDOWN;
  static final int TERMINATED;
  static final int STOP;
  static final int QUIET;
  static final int DORMANT;
  static final int INITIAL_QUEUE_CAPACITY;
  static final int MAXIMUM_QUEUE_CAPACITY;
  static final int TOP_BOUND_SHIFT;
  public static final java.util.concurrent.ForkJoinPool$ForkJoinWorkerThreadFactory defaultForkJoinWorkerThreadFactory;
  static final java.lang.RuntimePermission modifyThreadPermission;
  static final java.util.concurrent.ForkJoinPool common;
  static final int COMMON_PARALLELISM;
  volatile long stealCount;
  final long keepAlive;
  int indexSeed;
  final int bounds;
  volatile int mode;
  java.util.concurrent.ForkJoinPool$WorkQueue[] workQueues;
  final java.lang.String workerNamePrefix;
  final java.util.concurrent.ForkJoinPool$ForkJoinWorkerThreadFactory factory;
  final java.lang.Thread$UncaughtExceptionHandler ueh;
  final java.util.function.Predicate<? super java.util.concurrent.ForkJoinPool> saturate;
  volatile long ctl;
  static final java.lang.invoke.VarHandle QA;
  static java.security.AccessControlContext contextWithPermissions(java.security.Permission...);
  final java.util.concurrent.ForkJoinPool$WorkQueue registerWorker(java.util.concurrent.ForkJoinWorkerThread);
  final void deregisterWorker(java.util.concurrent.ForkJoinWorkerThread, java.lang.Throwable);
  final void signalWork();
  final void runWorker(java.util.concurrent.ForkJoinPool$WorkQueue);
  final int awaitJoin(java.util.concurrent.ForkJoinPool$WorkQueue, java.util.concurrent.ForkJoinTask<?>, long);
  final void helpQuiescePool(java.util.concurrent.ForkJoinPool$WorkQueue);
  final java.util.concurrent.ForkJoinTask<?> nextTaskFor(java.util.concurrent.ForkJoinPool$WorkQueue);
  final void externalPush(java.util.concurrent.ForkJoinTask<?>);
  static java.util.concurrent.ForkJoinPool$WorkQueue commonSubmitterQueue();
  final boolean tryExternalUnpush(java.util.concurrent.ForkJoinTask<?>);
  final int externalHelpComplete(java.util.concurrent.CountedCompleter<?>, int);
  final int helpComplete(java.util.concurrent.ForkJoinPool$WorkQueue, java.util.concurrent.CountedCompleter<?>, int);
  static int getSurplusQueuedTaskCount();
  public java.util.concurrent.ForkJoinPool();
  public java.util.concurrent.ForkJoinPool(int);
  public java.util.concurrent.ForkJoinPool(int, java.util.concurrent.ForkJoinPool$ForkJoinWorkerThreadFactory, java.lang.Thread$UncaughtExceptionHandler, boolean);
  public java.util.concurrent.ForkJoinPool(int, java.util.concurrent.ForkJoinPool$ForkJoinWorkerThreadFactory, java.lang.Thread$UncaughtExceptionHandler, boolean, int, int, int, java.util.function.Predicate<? super java.util.concurrent.ForkJoinPool>, long, java.util.concurrent.TimeUnit);
  public static java.util.concurrent.ForkJoinPool commonPool();
  public <T> T invoke(java.util.concurrent.ForkJoinTask<T>);
  public void execute(java.util.concurrent.ForkJoinTask<?>);
  public void execute(java.lang.Runnable);
  public <T> java.util.concurrent.ForkJoinTask<T> submit(java.util.concurrent.ForkJoinTask<T>);
  public <T> java.util.concurrent.ForkJoinTask<T> submit(java.util.concurrent.Callable<T>);
  public <T> java.util.concurrent.ForkJoinTask<T> submit(java.lang.Runnable, T);
  public java.util.concurrent.ForkJoinTask<?> submit(java.lang.Runnable);
  public <T> java.util.List<java.util.concurrent.Future<T>> invokeAll(java.util.Collection<? extends java.util.concurrent.Callable<T>>);
  public java.util.concurrent.ForkJoinPool$ForkJoinWorkerThreadFactory getFactory();
  public java.lang.Thread$UncaughtExceptionHandler getUncaughtExceptionHandler();
  public int getParallelism();
  public static int getCommonPoolParallelism();
  public int getPoolSize();
  public boolean getAsyncMode();
  public int getRunningThreadCount();
  public int getActiveThreadCount();
  public boolean isQuiescent();
  public long getStealCount();
  public long getQueuedTaskCount();
  public int getQueuedSubmissionCount();
  public boolean hasQueuedSubmissions();
  protected java.util.concurrent.ForkJoinTask<?> pollSubmission();
  protected int drainTasksTo(java.util.Collection<? super java.util.concurrent.ForkJoinTask<?>>);
  public java.lang.String toString();
  public void shutdown();
  public java.util.List<java.lang.Runnable> shutdownNow();
  public boolean isTerminated();
  public boolean isTerminating();
  public boolean isShutdown();
  public boolean awaitTermination(long, java.util.concurrent.TimeUnit) throws java.lang.InterruptedException;
  public boolean awaitQuiescence(long, java.util.concurrent.TimeUnit);
  static void quiesceCommonPool();
  public static void managedBlock(java.util.concurrent.ForkJoinPool$ManagedBlocker) throws java.lang.InterruptedException;
  static void helpAsyncBlocker(java.util.concurrent.Executor, java.util.concurrent.ForkJoinPool$ManagedBlocker);
  protected <T> java.util.concurrent.RunnableFuture<T> newTaskFor(java.lang.Runnable, T);
  protected <T> java.util.concurrent.RunnableFuture<T> newTaskFor(java.util.concurrent.Callable<T>);
  public java.util.concurrent.Future submit(java.util.concurrent.Callable);
  public java.util.concurrent.Future submit(java.lang.Runnable, java.lang.Object);
  public java.util.concurrent.Future submit(java.lang.Runnable);
  static {};
}
