Compiled from "CompletableFuture.java"
public class java.util.concurrent.CompletableFuture<T> implements java.util.concurrent.Future<T>, java.util.concurrent.CompletionStage<T> {
  volatile java.lang.Object result;
  volatile java.util.concurrent.CompletableFuture$Completion stack;
  static final java.util.concurrent.CompletableFuture$AltResult NIL;
  static final int SYNC;
  static final int ASYNC;
  static final int NESTED;
  final boolean internalComplete(java.lang.Object);
  final boolean tryPushStack(java.util.concurrent.CompletableFuture$Completion);
  final void pushStack(java.util.concurrent.CompletableFuture$Completion);
  final boolean completeNull();
  final java.lang.Object encodeValue(T);
  final boolean completeValue(T);
  static java.util.concurrent.CompletableFuture$AltResult encodeThrowable(java.lang.Throwable);
  final boolean completeThrowable(java.lang.Throwable);
  static java.lang.Object encodeThrowable(java.lang.Throwable, java.lang.Object);
  final boolean completeThrowable(java.lang.Throwable, java.lang.Object);
  java.lang.Object encodeOutcome(T, java.lang.Throwable);
  static java.lang.Object encodeRelay(java.lang.Object);
  final boolean completeRelay(java.lang.Object);
  static java.util.concurrent.Executor screenExecutor(java.util.concurrent.Executor);
  final void postComplete();
  final void cleanStack();
  final void unipush(java.util.concurrent.CompletableFuture$Completion);
  final java.util.concurrent.CompletableFuture<T> postFire(java.util.concurrent.CompletableFuture<?>, int);
  final boolean uniWhenComplete(java.lang.Object, java.util.function.BiConsumer<? super T, ? super java.lang.Throwable>, java.util.concurrent.CompletableFuture$UniWhenComplete<T>);
  final <S> boolean uniHandle(java.lang.Object, java.util.function.BiFunction<? super S, java.lang.Throwable, ? extends T>, java.util.concurrent.CompletableFuture$UniHandle<S, T>);
  final boolean uniExceptionally(java.lang.Object, java.util.function.Function<? super java.lang.Throwable, ? extends T>, java.util.concurrent.CompletableFuture$UniExceptionally<T>);
  final void bipush(java.util.concurrent.CompletableFuture<?>, java.util.concurrent.CompletableFuture$BiCompletion<?, ?, ?>);
  final java.util.concurrent.CompletableFuture<T> postFire(java.util.concurrent.CompletableFuture<?>, java.util.concurrent.CompletableFuture<?>, int);
  final <R, S> boolean biApply(java.lang.Object, java.lang.Object, java.util.function.BiFunction<? super R, ? super S, ? extends T>, java.util.concurrent.CompletableFuture$BiApply<R, S, T>);
  final <R, S> boolean biAccept(java.lang.Object, java.lang.Object, java.util.function.BiConsumer<? super R, ? super S>, java.util.concurrent.CompletableFuture$BiAccept<R, S>);
  final boolean biRun(java.lang.Object, java.lang.Object, java.lang.Runnable, java.util.concurrent.CompletableFuture$BiRun<?, ?>);
  static java.util.concurrent.CompletableFuture<java.lang.Void> andTree(java.util.concurrent.CompletableFuture<?>[], int, int);
  final void orpush(java.util.concurrent.CompletableFuture<?>, java.util.concurrent.CompletableFuture$BiCompletion<?, ?, ?>);
  static <U> java.util.concurrent.CompletableFuture<U> asyncSupplyStage(java.util.concurrent.Executor, java.util.function.Supplier<U>);
  static java.util.concurrent.CompletableFuture<java.lang.Void> asyncRunStage(java.util.concurrent.Executor, java.lang.Runnable);
  public java.util.concurrent.CompletableFuture();
  java.util.concurrent.CompletableFuture(java.lang.Object);
  public static <U> java.util.concurrent.CompletableFuture<U> supplyAsync(java.util.function.Supplier<U>);
  public static <U> java.util.concurrent.CompletableFuture<U> supplyAsync(java.util.function.Supplier<U>, java.util.concurrent.Executor);
  public static java.util.concurrent.CompletableFuture<java.lang.Void> runAsync(java.lang.Runnable);
  public static java.util.concurrent.CompletableFuture<java.lang.Void> runAsync(java.lang.Runnable, java.util.concurrent.Executor);
  public static <U> java.util.concurrent.CompletableFuture<U> completedFuture(U);
  public boolean isDone();
  public T get() throws java.lang.InterruptedException, java.util.concurrent.ExecutionException;
  public T get(long, java.util.concurrent.TimeUnit) throws java.lang.InterruptedException, java.util.concurrent.ExecutionException, java.util.concurrent.TimeoutException;
  public T join();
  public T getNow(T);
  public boolean complete(T);
  public boolean completeExceptionally(java.lang.Throwable);
  public <U> java.util.concurrent.CompletableFuture<U> thenApply(java.util.function.Function<? super T, ? extends U>);
  public <U> java.util.concurrent.CompletableFuture<U> thenApplyAsync(java.util.function.Function<? super T, ? extends U>);
  public <U> java.util.concurrent.CompletableFuture<U> thenApplyAsync(java.util.function.Function<? super T, ? extends U>, java.util.concurrent.Executor);
  public java.util.concurrent.CompletableFuture<java.lang.Void> thenAccept(java.util.function.Consumer<? super T>);
  public java.util.concurrent.CompletableFuture<java.lang.Void> thenAcceptAsync(java.util.function.Consumer<? super T>);
  public java.util.concurrent.CompletableFuture<java.lang.Void> thenAcceptAsync(java.util.function.Consumer<? super T>, java.util.concurrent.Executor);
  public java.util.concurrent.CompletableFuture<java.lang.Void> thenRun(java.lang.Runnable);
  public java.util.concurrent.CompletableFuture<java.lang.Void> thenRunAsync(java.lang.Runnable);
  public java.util.concurrent.CompletableFuture<java.lang.Void> thenRunAsync(java.lang.Runnable, java.util.concurrent.Executor);
  public <U, V> java.util.concurrent.CompletableFuture<V> thenCombine(java.util.concurrent.CompletionStage<? extends U>, java.util.function.BiFunction<? super T, ? super U, ? extends V>);
  public <U, V> java.util.concurrent.CompletableFuture<V> thenCombineAsync(java.util.concurrent.CompletionStage<? extends U>, java.util.function.BiFunction<? super T, ? super U, ? extends V>);
  public <U, V> java.util.concurrent.CompletableFuture<V> thenCombineAsync(java.util.concurrent.CompletionStage<? extends U>, java.util.function.BiFunction<? super T, ? super U, ? extends V>, java.util.concurrent.Executor);
  public <U> java.util.concurrent.CompletableFuture<java.lang.Void> thenAcceptBoth(java.util.concurrent.CompletionStage<? extends U>, java.util.function.BiConsumer<? super T, ? super U>);
  public <U> java.util.concurrent.CompletableFuture<java.lang.Void> thenAcceptBothAsync(java.util.concurrent.CompletionStage<? extends U>, java.util.function.BiConsumer<? super T, ? super U>);
  public <U> java.util.concurrent.CompletableFuture<java.lang.Void> thenAcceptBothAsync(java.util.concurrent.CompletionStage<? extends U>, java.util.function.BiConsumer<? super T, ? super U>, java.util.concurrent.Executor);
  public java.util.concurrent.CompletableFuture<java.lang.Void> runAfterBoth(java.util.concurrent.CompletionStage<?>, java.lang.Runnable);
  public java.util.concurrent.CompletableFuture<java.lang.Void> runAfterBothAsync(java.util.concurrent.CompletionStage<?>, java.lang.Runnable);
  public java.util.concurrent.CompletableFuture<java.lang.Void> runAfterBothAsync(java.util.concurrent.CompletionStage<?>, java.lang.Runnable, java.util.concurrent.Executor);
  public <U> java.util.concurrent.CompletableFuture<U> applyToEither(java.util.concurrent.CompletionStage<? extends T>, java.util.function.Function<? super T, U>);
  public <U> java.util.concurrent.CompletableFuture<U> applyToEitherAsync(java.util.concurrent.CompletionStage<? extends T>, java.util.function.Function<? super T, U>);
  public <U> java.util.concurrent.CompletableFuture<U> applyToEitherAsync(java.util.concurrent.CompletionStage<? extends T>, java.util.function.Function<? super T, U>, java.util.concurrent.Executor);
  public java.util.concurrent.CompletableFuture<java.lang.Void> acceptEither(java.util.concurrent.CompletionStage<? extends T>, java.util.function.Consumer<? super T>);
  public java.util.concurrent.CompletableFuture<java.lang.Void> acceptEitherAsync(java.util.concurrent.CompletionStage<? extends T>, java.util.function.Consumer<? super T>);
  public java.util.concurrent.CompletableFuture<java.lang.Void> acceptEitherAsync(java.util.concurrent.CompletionStage<? extends T>, java.util.function.Consumer<? super T>, java.util.concurrent.Executor);
  public java.util.concurrent.CompletableFuture<java.lang.Void> runAfterEither(java.util.concurrent.CompletionStage<?>, java.lang.Runnable);
  public java.util.concurrent.CompletableFuture<java.lang.Void> runAfterEitherAsync(java.util.concurrent.CompletionStage<?>, java.lang.Runnable);
  public java.util.concurrent.CompletableFuture<java.lang.Void> runAfterEitherAsync(java.util.concurrent.CompletionStage<?>, java.lang.Runnable, java.util.concurrent.Executor);
  public <U> java.util.concurrent.CompletableFuture<U> thenCompose(java.util.function.Function<? super T, ? extends java.util.concurrent.CompletionStage<U>>);
  public <U> java.util.concurrent.CompletableFuture<U> thenComposeAsync(java.util.function.Function<? super T, ? extends java.util.concurrent.CompletionStage<U>>);
  public <U> java.util.concurrent.CompletableFuture<U> thenComposeAsync(java.util.function.Function<? super T, ? extends java.util.concurrent.CompletionStage<U>>, java.util.concurrent.Executor);
  public java.util.concurrent.CompletableFuture<T> whenComplete(java.util.function.BiConsumer<? super T, ? super java.lang.Throwable>);
  public java.util.concurrent.CompletableFuture<T> whenCompleteAsync(java.util.function.BiConsumer<? super T, ? super java.lang.Throwable>);
  public java.util.concurrent.CompletableFuture<T> whenCompleteAsync(java.util.function.BiConsumer<? super T, ? super java.lang.Throwable>, java.util.concurrent.Executor);
  public <U> java.util.concurrent.CompletableFuture<U> handle(java.util.function.BiFunction<? super T, java.lang.Throwable, ? extends U>);
  public <U> java.util.concurrent.CompletableFuture<U> handleAsync(java.util.function.BiFunction<? super T, java.lang.Throwable, ? extends U>);
  public <U> java.util.concurrent.CompletableFuture<U> handleAsync(java.util.function.BiFunction<? super T, java.lang.Throwable, ? extends U>, java.util.concurrent.Executor);
  public java.util.concurrent.CompletableFuture<T> toCompletableFuture();
  public java.util.concurrent.CompletableFuture<T> exceptionally(java.util.function.Function<java.lang.Throwable, ? extends T>);
  public static java.util.concurrent.CompletableFuture<java.lang.Void> allOf(java.util.concurrent.CompletableFuture<?>...);
  public static java.util.concurrent.CompletableFuture<java.lang.Object> anyOf(java.util.concurrent.CompletableFuture<?>...);
  public boolean cancel(boolean);
  public boolean isCancelled();
  public boolean isCompletedExceptionally();
  public void obtrudeValue(T);
  public void obtrudeException(java.lang.Throwable);
  public int getNumberOfDependents();
  public java.lang.String toString();
  public <U> java.util.concurrent.CompletableFuture<U> newIncompleteFuture();
  public java.util.concurrent.Executor defaultExecutor();
  public java.util.concurrent.CompletableFuture<T> copy();
  public java.util.concurrent.CompletionStage<T> minimalCompletionStage();
  public java.util.concurrent.CompletableFuture<T> completeAsync(java.util.function.Supplier<? extends T>, java.util.concurrent.Executor);
  public java.util.concurrent.CompletableFuture<T> completeAsync(java.util.function.Supplier<? extends T>);
  public java.util.concurrent.CompletableFuture<T> orTimeout(long, java.util.concurrent.TimeUnit);
  public java.util.concurrent.CompletableFuture<T> completeOnTimeout(T, long, java.util.concurrent.TimeUnit);
  public static java.util.concurrent.Executor delayedExecutor(long, java.util.concurrent.TimeUnit, java.util.concurrent.Executor);
  public static java.util.concurrent.Executor delayedExecutor(long, java.util.concurrent.TimeUnit);
  public static <U> java.util.concurrent.CompletionStage<U> completedStage(U);
  public static <U> java.util.concurrent.CompletableFuture<U> failedFuture(java.lang.Throwable);
  public static <U> java.util.concurrent.CompletionStage<U> failedStage(java.lang.Throwable);
  public java.util.concurrent.CompletionStage exceptionally(java.util.function.Function);
  public java.util.concurrent.CompletionStage whenCompleteAsync(java.util.function.BiConsumer, java.util.concurrent.Executor);
  public java.util.concurrent.CompletionStage whenCompleteAsync(java.util.function.BiConsumer);
  public java.util.concurrent.CompletionStage whenComplete(java.util.function.BiConsumer);
  public java.util.concurrent.CompletionStage handleAsync(java.util.function.BiFunction, java.util.concurrent.Executor);
  public java.util.concurrent.CompletionStage handleAsync(java.util.function.BiFunction);
  public java.util.concurrent.CompletionStage handle(java.util.function.BiFunction);
  public java.util.concurrent.CompletionStage thenComposeAsync(java.util.function.Function, java.util.concurrent.Executor);
  public java.util.concurrent.CompletionStage thenComposeAsync(java.util.function.Function);
  public java.util.concurrent.CompletionStage thenCompose(java.util.function.Function);
  public java.util.concurrent.CompletionStage runAfterEitherAsync(java.util.concurrent.CompletionStage, java.lang.Runnable, java.util.concurrent.Executor);
  public java.util.concurrent.CompletionStage runAfterEitherAsync(java.util.concurrent.CompletionStage, java.lang.Runnable);
  public java.util.concurrent.CompletionStage runAfterEither(java.util.concurrent.CompletionStage, java.lang.Runnable);
  public java.util.concurrent.CompletionStage acceptEitherAsync(java.util.concurrent.CompletionStage, java.util.function.Consumer, java.util.concurrent.Executor);
  public java.util.concurrent.CompletionStage acceptEitherAsync(java.util.concurrent.CompletionStage, java.util.function.Consumer);
  public java.util.concurrent.CompletionStage acceptEither(java.util.concurrent.CompletionStage, java.util.function.Consumer);
  public java.util.concurrent.CompletionStage applyToEitherAsync(java.util.concurrent.CompletionStage, java.util.function.Function, java.util.concurrent.Executor);
  public java.util.concurrent.CompletionStage applyToEitherAsync(java.util.concurrent.CompletionStage, java.util.function.Function);
  public java.util.concurrent.CompletionStage applyToEither(java.util.concurrent.CompletionStage, java.util.function.Function);
  public java.util.concurrent.CompletionStage runAfterBothAsync(java.util.concurrent.CompletionStage, java.lang.Runnable, java.util.concurrent.Executor);
  public java.util.concurrent.CompletionStage runAfterBothAsync(java.util.concurrent.CompletionStage, java.lang.Runnable);
  public java.util.concurrent.CompletionStage runAfterBoth(java.util.concurrent.CompletionStage, java.lang.Runnable);
  public java.util.concurrent.CompletionStage thenAcceptBothAsync(java.util.concurrent.CompletionStage, java.util.function.BiConsumer, java.util.concurrent.Executor);
  public java.util.concurrent.CompletionStage thenAcceptBothAsync(java.util.concurrent.CompletionStage, java.util.function.BiConsumer);
  public java.util.concurrent.CompletionStage thenAcceptBoth(java.util.concurrent.CompletionStage, java.util.function.BiConsumer);
  public java.util.concurrent.CompletionStage thenCombineAsync(java.util.concurrent.CompletionStage, java.util.function.BiFunction, java.util.concurrent.Executor);
  public java.util.concurrent.CompletionStage thenCombineAsync(java.util.concurrent.CompletionStage, java.util.function.BiFunction);
  public java.util.concurrent.CompletionStage thenCombine(java.util.concurrent.CompletionStage, java.util.function.BiFunction);
  public java.util.concurrent.CompletionStage thenRunAsync(java.lang.Runnable, java.util.concurrent.Executor);
  public java.util.concurrent.CompletionStage thenRunAsync(java.lang.Runnable);
  public java.util.concurrent.CompletionStage thenRun(java.lang.Runnable);
  public java.util.concurrent.CompletionStage thenAcceptAsync(java.util.function.Consumer, java.util.concurrent.Executor);
  public java.util.concurrent.CompletionStage thenAcceptAsync(java.util.function.Consumer);
  public java.util.concurrent.CompletionStage thenAccept(java.util.function.Consumer);
  public java.util.concurrent.CompletionStage thenApplyAsync(java.util.function.Function, java.util.concurrent.Executor);
  public java.util.concurrent.CompletionStage thenApplyAsync(java.util.function.Function);
  public java.util.concurrent.CompletionStage thenApply(java.util.function.Function);
  static {};
}
