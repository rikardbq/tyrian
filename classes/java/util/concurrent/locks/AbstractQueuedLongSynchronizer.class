Compiled from "AbstractQueuedLongSynchronizer.java"
public abstract class java.util.concurrent.locks.AbstractQueuedLongSynchronizer extends java.util.concurrent.locks.AbstractOwnableSynchronizer implements java.io.Serializable {
  static final long SPIN_FOR_TIMEOUT_THRESHOLD;
  protected java.util.concurrent.locks.AbstractQueuedLongSynchronizer();
  protected final long getState();
  protected final void setState(long);
  protected final boolean compareAndSetState(long, long);
  static void selfInterrupt();
  final boolean acquireQueued(java.util.concurrent.locks.AbstractQueuedSynchronizer$Node, long);
  protected boolean tryAcquire(long);
  protected boolean tryRelease(long);
  protected long tryAcquireShared(long);
  protected boolean tryReleaseShared(long);
  protected boolean isHeldExclusively();
  public final void acquire(long);
  public final void acquireInterruptibly(long) throws java.lang.InterruptedException;
  public final boolean tryAcquireNanos(long, long) throws java.lang.InterruptedException;
  public final boolean release(long);
  public final void acquireShared(long);
  public final void acquireSharedInterruptibly(long) throws java.lang.InterruptedException;
  public final boolean tryAcquireSharedNanos(long, long) throws java.lang.InterruptedException;
  public final boolean releaseShared(long);
  public final boolean hasQueuedThreads();
  public final boolean hasContended();
  public final java.lang.Thread getFirstQueuedThread();
  public final boolean isQueued(java.lang.Thread);
  final boolean apparentlyFirstQueuedIsExclusive();
  public final boolean hasQueuedPredecessors();
  public final int getQueueLength();
  public final java.util.Collection<java.lang.Thread> getQueuedThreads();
  public final java.util.Collection<java.lang.Thread> getExclusiveQueuedThreads();
  public final java.util.Collection<java.lang.Thread> getSharedQueuedThreads();
  public java.lang.String toString();
  final boolean isOnSyncQueue(java.util.concurrent.locks.AbstractQueuedSynchronizer$Node);
  final boolean transferForSignal(java.util.concurrent.locks.AbstractQueuedSynchronizer$Node);
  final boolean transferAfterCancelledWait(java.util.concurrent.locks.AbstractQueuedSynchronizer$Node);
  final long fullyRelease(java.util.concurrent.locks.AbstractQueuedSynchronizer$Node);
  public final boolean owns(java.util.concurrent.locks.AbstractQueuedLongSynchronizer$ConditionObject);
  public final boolean hasWaiters(java.util.concurrent.locks.AbstractQueuedLongSynchronizer$ConditionObject);
  public final int getWaitQueueLength(java.util.concurrent.locks.AbstractQueuedLongSynchronizer$ConditionObject);
  public final java.util.Collection<java.lang.Thread> getWaitingThreads(java.util.concurrent.locks.AbstractQueuedLongSynchronizer$ConditionObject);
  static {};
}
