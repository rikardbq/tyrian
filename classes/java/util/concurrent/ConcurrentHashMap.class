Compiled from "ConcurrentHashMap.java"
public class java.util.concurrent.ConcurrentHashMap<K, V> extends java.util.AbstractMap<K, V> implements java.util.concurrent.ConcurrentMap<K, V>, java.io.Serializable {
  static final int MAX_ARRAY_SIZE;
  static final int TREEIFY_THRESHOLD;
  static final int UNTREEIFY_THRESHOLD;
  static final int MIN_TREEIFY_CAPACITY;
  static final int MOVED;
  static final int TREEBIN;
  static final int RESERVED;
  static final int HASH_BITS;
  static final int NCPU;
  volatile transient java.util.concurrent.ConcurrentHashMap$Node<K, V>[] table;
  static final int spread(int);
  static java.lang.Class<?> comparableClassFor(java.lang.Object);
  static int compareComparables(java.lang.Class<?>, java.lang.Object, java.lang.Object);
  static final <K, V> java.util.concurrent.ConcurrentHashMap$Node<K, V> tabAt(java.util.concurrent.ConcurrentHashMap$Node<K, V>[], int);
  static final <K, V> boolean casTabAt(java.util.concurrent.ConcurrentHashMap$Node<K, V>[], int, java.util.concurrent.ConcurrentHashMap$Node<K, V>, java.util.concurrent.ConcurrentHashMap$Node<K, V>);
  static final <K, V> void setTabAt(java.util.concurrent.ConcurrentHashMap$Node<K, V>[], int, java.util.concurrent.ConcurrentHashMap$Node<K, V>);
  public java.util.concurrent.ConcurrentHashMap();
  public java.util.concurrent.ConcurrentHashMap(int);
  public java.util.concurrent.ConcurrentHashMap(java.util.Map<? extends K, ? extends V>);
  public java.util.concurrent.ConcurrentHashMap(int, float);
  public java.util.concurrent.ConcurrentHashMap(int, float, int);
  public int size();
  public boolean isEmpty();
  public V get(java.lang.Object);
  public boolean containsKey(java.lang.Object);
  public boolean containsValue(java.lang.Object);
  public V put(K, V);
  final V putVal(K, V, boolean);
  public void putAll(java.util.Map<? extends K, ? extends V>);
  public V remove(java.lang.Object);
  final V replaceNode(java.lang.Object, V, java.lang.Object);
  public void clear();
  public java.util.concurrent.ConcurrentHashMap$KeySetView<K, V> keySet();
  public java.util.Collection<V> values();
  public java.util.Set<java.util.Map$Entry<K, V>> entrySet();
  public int hashCode();
  public java.lang.String toString();
  public boolean equals(java.lang.Object);
  public V putIfAbsent(K, V);
  public boolean remove(java.lang.Object, java.lang.Object);
  public boolean replace(K, V, V);
  public V replace(K, V);
  public V getOrDefault(java.lang.Object, V);
  public void forEach(java.util.function.BiConsumer<? super K, ? super V>);
  public void replaceAll(java.util.function.BiFunction<? super K, ? super V, ? extends V>);
  boolean removeEntryIf(java.util.function.Predicate<? super java.util.Map$Entry<K, V>>);
  boolean removeValueIf(java.util.function.Predicate<? super V>);
  public V computeIfAbsent(K, java.util.function.Function<? super K, ? extends V>);
  public V computeIfPresent(K, java.util.function.BiFunction<? super K, ? super V, ? extends V>);
  public V compute(K, java.util.function.BiFunction<? super K, ? super V, ? extends V>);
  public V merge(K, V, java.util.function.BiFunction<? super V, ? super V, ? extends V>);
  public boolean contains(java.lang.Object);
  public java.util.Enumeration<K> keys();
  public java.util.Enumeration<V> elements();
  public long mappingCount();
  public static <K> java.util.concurrent.ConcurrentHashMap$KeySetView<K, java.lang.Boolean> newKeySet();
  public static <K> java.util.concurrent.ConcurrentHashMap$KeySetView<K, java.lang.Boolean> newKeySet(int);
  public java.util.concurrent.ConcurrentHashMap$KeySetView<K, V> keySet(V);
  static final int resizeStamp(int);
  final java.util.concurrent.ConcurrentHashMap$Node<K, V>[] helpTransfer(java.util.concurrent.ConcurrentHashMap$Node<K, V>[], java.util.concurrent.ConcurrentHashMap$Node<K, V>);
  final long sumCount();
  static <K, V> java.util.concurrent.ConcurrentHashMap$Node<K, V> untreeify(java.util.concurrent.ConcurrentHashMap$Node<K, V>);
  final int batchFor(long);
  public void forEach(long, java.util.function.BiConsumer<? super K, ? super V>);
  public <U> void forEach(long, java.util.function.BiFunction<? super K, ? super V, ? extends U>, java.util.function.Consumer<? super U>);
  public <U> U search(long, java.util.function.BiFunction<? super K, ? super V, ? extends U>);
  public <U> U reduce(long, java.util.function.BiFunction<? super K, ? super V, ? extends U>, java.util.function.BiFunction<? super U, ? super U, ? extends U>);
  public double reduceToDouble(long, java.util.function.ToDoubleBiFunction<? super K, ? super V>, double, java.util.function.DoubleBinaryOperator);
  public long reduceToLong(long, java.util.function.ToLongBiFunction<? super K, ? super V>, long, java.util.function.LongBinaryOperator);
  public int reduceToInt(long, java.util.function.ToIntBiFunction<? super K, ? super V>, int, java.util.function.IntBinaryOperator);
  public void forEachKey(long, java.util.function.Consumer<? super K>);
  public <U> void forEachKey(long, java.util.function.Function<? super K, ? extends U>, java.util.function.Consumer<? super U>);
  public <U> U searchKeys(long, java.util.function.Function<? super K, ? extends U>);
  public K reduceKeys(long, java.util.function.BiFunction<? super K, ? super K, ? extends K>);
  public <U> U reduceKeys(long, java.util.function.Function<? super K, ? extends U>, java.util.function.BiFunction<? super U, ? super U, ? extends U>);
  public double reduceKeysToDouble(long, java.util.function.ToDoubleFunction<? super K>, double, java.util.function.DoubleBinaryOperator);
  public long reduceKeysToLong(long, java.util.function.ToLongFunction<? super K>, long, java.util.function.LongBinaryOperator);
  public int reduceKeysToInt(long, java.util.function.ToIntFunction<? super K>, int, java.util.function.IntBinaryOperator);
  public void forEachValue(long, java.util.function.Consumer<? super V>);
  public <U> void forEachValue(long, java.util.function.Function<? super V, ? extends U>, java.util.function.Consumer<? super U>);
  public <U> U searchValues(long, java.util.function.Function<? super V, ? extends U>);
  public V reduceValues(long, java.util.function.BiFunction<? super V, ? super V, ? extends V>);
  public <U> U reduceValues(long, java.util.function.Function<? super V, ? extends U>, java.util.function.BiFunction<? super U, ? super U, ? extends U>);
  public double reduceValuesToDouble(long, java.util.function.ToDoubleFunction<? super V>, double, java.util.function.DoubleBinaryOperator);
  public long reduceValuesToLong(long, java.util.function.ToLongFunction<? super V>, long, java.util.function.LongBinaryOperator);
  public int reduceValuesToInt(long, java.util.function.ToIntFunction<? super V>, int, java.util.function.IntBinaryOperator);
  public void forEachEntry(long, java.util.function.Consumer<? super java.util.Map$Entry<K, V>>);
  public <U> void forEachEntry(long, java.util.function.Function<java.util.Map$Entry<K, V>, ? extends U>, java.util.function.Consumer<? super U>);
  public <U> U searchEntries(long, java.util.function.Function<java.util.Map$Entry<K, V>, ? extends U>);
  public java.util.Map$Entry<K, V> reduceEntries(long, java.util.function.BiFunction<java.util.Map$Entry<K, V>, java.util.Map$Entry<K, V>, ? extends java.util.Map$Entry<K, V>>);
  public <U> U reduceEntries(long, java.util.function.Function<java.util.Map$Entry<K, V>, ? extends U>, java.util.function.BiFunction<? super U, ? super U, ? extends U>);
  public double reduceEntriesToDouble(long, java.util.function.ToDoubleFunction<java.util.Map$Entry<K, V>>, double, java.util.function.DoubleBinaryOperator);
  public long reduceEntriesToLong(long, java.util.function.ToLongFunction<java.util.Map$Entry<K, V>>, long, java.util.function.LongBinaryOperator);
  public int reduceEntriesToInt(long, java.util.function.ToIntFunction<java.util.Map$Entry<K, V>>, int, java.util.function.IntBinaryOperator);
  public java.util.Set keySet();
  static {};
}
