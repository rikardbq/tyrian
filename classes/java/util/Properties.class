Compiled from "Properties.java"
public class java.util.Properties extends java.util.Hashtable<java.lang.Object, java.lang.Object> {
  protected volatile java.util.Properties defaults;
  public java.util.Properties();
  public java.util.Properties(int);
  public java.util.Properties(java.util.Properties);
  public synchronized java.lang.Object setProperty(java.lang.String, java.lang.String);
  public synchronized void load(java.io.Reader) throws java.io.IOException;
  public synchronized void load(java.io.InputStream) throws java.io.IOException;
  public void save(java.io.OutputStream, java.lang.String);
  public void store(java.io.Writer, java.lang.String) throws java.io.IOException;
  public void store(java.io.OutputStream, java.lang.String) throws java.io.IOException;
  public synchronized void loadFromXML(java.io.InputStream) throws java.io.IOException, java.util.InvalidPropertiesFormatException;
  public void storeToXML(java.io.OutputStream, java.lang.String) throws java.io.IOException;
  public void storeToXML(java.io.OutputStream, java.lang.String, java.lang.String) throws java.io.IOException;
  public void storeToXML(java.io.OutputStream, java.lang.String, java.nio.charset.Charset) throws java.io.IOException;
  public java.lang.String getProperty(java.lang.String);
  public java.lang.String getProperty(java.lang.String, java.lang.String);
  public java.util.Enumeration<?> propertyNames();
  public java.util.Set<java.lang.String> stringPropertyNames();
  public void list(java.io.PrintStream);
  public void list(java.io.PrintWriter);
  public int size();
  public boolean isEmpty();
  public java.util.Enumeration<java.lang.Object> keys();
  public java.util.Enumeration<java.lang.Object> elements();
  public boolean contains(java.lang.Object);
  public boolean containsValue(java.lang.Object);
  public boolean containsKey(java.lang.Object);
  public java.lang.Object get(java.lang.Object);
  public synchronized java.lang.Object put(java.lang.Object, java.lang.Object);
  public synchronized java.lang.Object remove(java.lang.Object);
  public synchronized void putAll(java.util.Map<?, ?>);
  public synchronized void clear();
  public synchronized java.lang.String toString();
  public java.util.Set<java.lang.Object> keySet();
  public java.util.Collection<java.lang.Object> values();
  public java.util.Set<java.util.Map$Entry<java.lang.Object, java.lang.Object>> entrySet();
  public synchronized boolean equals(java.lang.Object);
  public synchronized int hashCode();
  public java.lang.Object getOrDefault(java.lang.Object, java.lang.Object);
  public synchronized void forEach(java.util.function.BiConsumer<? super java.lang.Object, ? super java.lang.Object>);
  public synchronized void replaceAll(java.util.function.BiFunction<? super java.lang.Object, ? super java.lang.Object, ?>);
  public synchronized java.lang.Object putIfAbsent(java.lang.Object, java.lang.Object);
  public synchronized boolean remove(java.lang.Object, java.lang.Object);
  public synchronized boolean replace(java.lang.Object, java.lang.Object, java.lang.Object);
  public synchronized java.lang.Object replace(java.lang.Object, java.lang.Object);
  public synchronized java.lang.Object computeIfAbsent(java.lang.Object, java.util.function.Function<? super java.lang.Object, ?>);
  public synchronized java.lang.Object computeIfPresent(java.lang.Object, java.util.function.BiFunction<? super java.lang.Object, ? super java.lang.Object, ?>);
  public synchronized java.lang.Object compute(java.lang.Object, java.util.function.BiFunction<? super java.lang.Object, ? super java.lang.Object, ?>);
  public synchronized java.lang.Object merge(java.lang.Object, java.lang.Object, java.util.function.BiFunction<? super java.lang.Object, ? super java.lang.Object, ?>);
  protected void rehash();
  public synchronized java.lang.Object clone();
  void writeHashtable(java.io.ObjectOutputStream) throws java.io.IOException;
  void readHashtable(java.io.ObjectInputStream) throws java.io.IOException, java.lang.ClassNotFoundException;
  static {};
}
