Compiled from "MethodType.java"
public final class java.lang.invoke.MethodType implements java.io.Serializable {
  static final int MAX_JVM_ARITY;
  static final int MAX_MH_ARITY;
  static final int MAX_MH_INVOKER_ARITY;
  static final java.lang.invoke.MethodType$ConcurrentWeakInternSet<java.lang.invoke.MethodType> internTable;
  static final java.lang.Class<?>[] NO_PTYPES;
  static final boolean $assertionsDisabled;
  java.lang.invoke.MethodTypeForm form();
  java.lang.Class<?> rtype();
  java.lang.Class<?>[] ptypes();
  void setForm(java.lang.invoke.MethodTypeForm);
  static void checkSlotCount(int);
  public static java.lang.invoke.MethodType methodType(java.lang.Class<?>, java.lang.Class<?>[]);
  public static java.lang.invoke.MethodType methodType(java.lang.Class<?>, java.util.List<java.lang.Class<?>>);
  public static java.lang.invoke.MethodType methodType(java.lang.Class<?>, java.lang.Class<?>, java.lang.Class<?>...);
  public static java.lang.invoke.MethodType methodType(java.lang.Class<?>);
  public static java.lang.invoke.MethodType methodType(java.lang.Class<?>, java.lang.Class<?>);
  public static java.lang.invoke.MethodType methodType(java.lang.Class<?>, java.lang.invoke.MethodType);
  static java.lang.invoke.MethodType makeImpl(java.lang.Class<?>, java.lang.Class<?>[], boolean);
  public static java.lang.invoke.MethodType genericMethodType(int, boolean);
  public static java.lang.invoke.MethodType genericMethodType(int);
  public java.lang.invoke.MethodType changeParameterType(int, java.lang.Class<?>);
  public java.lang.invoke.MethodType insertParameterTypes(int, java.lang.Class<?>...);
  public java.lang.invoke.MethodType appendParameterTypes(java.lang.Class<?>...);
  public java.lang.invoke.MethodType insertParameterTypes(int, java.util.List<java.lang.Class<?>>);
  public java.lang.invoke.MethodType appendParameterTypes(java.util.List<java.lang.Class<?>>);
  java.lang.invoke.MethodType replaceParameterTypes(int, int, java.lang.Class<?>...);
  java.lang.invoke.MethodType asSpreaderType(java.lang.Class<?>, int, int);
  java.lang.Class<?> leadingReferenceParameter();
  java.lang.invoke.MethodType asCollectorType(java.lang.Class<?>, int, int);
  public java.lang.invoke.MethodType dropParameterTypes(int, int);
  public java.lang.invoke.MethodType changeReturnType(java.lang.Class<?>);
  public boolean hasPrimitives();
  public boolean hasWrappers();
  public java.lang.invoke.MethodType erase();
  java.lang.invoke.MethodType basicType();
  java.lang.invoke.MethodType invokerType();
  public java.lang.invoke.MethodType generic();
  boolean isGeneric();
  public java.lang.invoke.MethodType wrap();
  public java.lang.invoke.MethodType unwrap();
  public java.lang.Class<?> parameterType(int);
  public int parameterCount();
  public java.lang.Class<?> returnType();
  public java.util.List<java.lang.Class<?>> parameterList();
  public java.lang.Class<?> lastParameterType();
  public java.lang.Class<?>[] parameterArray();
  public boolean equals(java.lang.Object);
  public int hashCode();
  public java.lang.String toString();
  boolean effectivelyIdenticalParameters(int, java.util.List<java.lang.Class<?>>);
  boolean isViewableAs(java.lang.invoke.MethodType, boolean);
  boolean isConvertibleTo(java.lang.invoke.MethodType);
  boolean explicitCastEquivalentToAsType(java.lang.invoke.MethodType);
  static boolean canConvert(java.lang.Class<?>, java.lang.Class<?>);
  int parameterSlotCount();
  java.lang.invoke.Invokers invokers();
  int parameterSlotDepth(int);
  int returnSlotCount();
  public static java.lang.invoke.MethodType fromMethodDescriptorString(java.lang.String, java.lang.ClassLoader) throws java.lang.IllegalArgumentException, java.lang.TypeNotPresentException;
  static java.lang.invoke.MethodType fromDescriptor(java.lang.String, java.lang.ClassLoader) throws java.lang.IllegalArgumentException, java.lang.TypeNotPresentException;
  public java.lang.String toMethodDescriptorString();
  static java.lang.String toFieldDescriptorString(java.lang.Class<?>);
  static {};
}
