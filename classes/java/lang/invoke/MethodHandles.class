Compiled from "MethodHandles.java"
public class java.lang.invoke.MethodHandles {
  static final java.lang.invoke.MemberName$Factory IMPL_NAMES;
  static final boolean $assertionsDisabled;
  public static java.lang.invoke.MethodHandles$Lookup lookup();
  public static java.lang.invoke.MethodHandles$Lookup publicLookup();
  public static java.lang.invoke.MethodHandles$Lookup privateLookupIn(java.lang.Class<?>, java.lang.invoke.MethodHandles$Lookup) throws java.lang.IllegalAccessException;
  public static <T extends java.lang.reflect.Member> T reflectAs(java.lang.Class<T>, java.lang.invoke.MethodHandle);
  public static java.lang.invoke.MethodHandle arrayConstructor(java.lang.Class<?>) throws java.lang.IllegalArgumentException;
  public static java.lang.invoke.MethodHandle arrayLength(java.lang.Class<?>) throws java.lang.IllegalArgumentException;
  public static java.lang.invoke.MethodHandle arrayElementGetter(java.lang.Class<?>) throws java.lang.IllegalArgumentException;
  public static java.lang.invoke.MethodHandle arrayElementSetter(java.lang.Class<?>) throws java.lang.IllegalArgumentException;
  public static java.lang.invoke.VarHandle arrayElementVarHandle(java.lang.Class<?>) throws java.lang.IllegalArgumentException;
  public static java.lang.invoke.VarHandle byteArrayViewVarHandle(java.lang.Class<?>, java.nio.ByteOrder) throws java.lang.IllegalArgumentException;
  public static java.lang.invoke.VarHandle byteBufferViewVarHandle(java.lang.Class<?>, java.nio.ByteOrder) throws java.lang.IllegalArgumentException;
  public static java.lang.invoke.MethodHandle spreadInvoker(java.lang.invoke.MethodType, int);
  public static java.lang.invoke.MethodHandle exactInvoker(java.lang.invoke.MethodType);
  public static java.lang.invoke.MethodHandle invoker(java.lang.invoke.MethodType);
  public static java.lang.invoke.MethodHandle varHandleExactInvoker(java.lang.invoke.VarHandle$AccessMode, java.lang.invoke.MethodType);
  public static java.lang.invoke.MethodHandle varHandleInvoker(java.lang.invoke.VarHandle$AccessMode, java.lang.invoke.MethodType);
  static java.lang.invoke.MethodHandle basicInvoker(java.lang.invoke.MethodType);
  public static java.lang.invoke.MethodHandle explicitCastArguments(java.lang.invoke.MethodHandle, java.lang.invoke.MethodType);
  public static java.lang.invoke.MethodHandle permuteArguments(java.lang.invoke.MethodHandle, java.lang.invoke.MethodType, int...);
  public static java.lang.invoke.MethodHandle constant(java.lang.Class<?>, java.lang.Object);
  public static java.lang.invoke.MethodHandle identity(java.lang.Class<?>);
  public static java.lang.invoke.MethodHandle zero(java.lang.Class<?>);
  public static java.lang.invoke.MethodHandle empty(java.lang.invoke.MethodType);
  public static java.lang.invoke.MethodHandle insertArguments(java.lang.invoke.MethodHandle, int, java.lang.Object...);
  public static java.lang.invoke.MethodHandle dropArguments(java.lang.invoke.MethodHandle, int, java.util.List<java.lang.Class<?>>);
  public static java.lang.invoke.MethodHandle dropArguments(java.lang.invoke.MethodHandle, int, java.lang.Class<?>...);
  public static java.lang.invoke.MethodHandle dropArgumentsToMatch(java.lang.invoke.MethodHandle, int, java.util.List<java.lang.Class<?>>, int);
  public static java.lang.invoke.MethodHandle filterArguments(java.lang.invoke.MethodHandle, int, java.lang.invoke.MethodHandle...);
  static java.lang.invoke.MethodHandle filterArgument(java.lang.invoke.MethodHandle, int, java.lang.invoke.MethodHandle);
  public static java.lang.invoke.MethodHandle collectArguments(java.lang.invoke.MethodHandle, int, java.lang.invoke.MethodHandle);
  public static java.lang.invoke.MethodHandle filterReturnValue(java.lang.invoke.MethodHandle, java.lang.invoke.MethodHandle);
  public static java.lang.invoke.MethodHandle foldArguments(java.lang.invoke.MethodHandle, java.lang.invoke.MethodHandle);
  public static java.lang.invoke.MethodHandle foldArguments(java.lang.invoke.MethodHandle, int, java.lang.invoke.MethodHandle);
  static java.lang.invoke.MethodHandle foldArguments(java.lang.invoke.MethodHandle, int, java.lang.invoke.MethodHandle, int...);
  public static java.lang.invoke.MethodHandle guardWithTest(java.lang.invoke.MethodHandle, java.lang.invoke.MethodHandle, java.lang.invoke.MethodHandle);
  static <T> java.lang.RuntimeException misMatchedTypes(java.lang.String, T, T);
  public static java.lang.invoke.MethodHandle catchException(java.lang.invoke.MethodHandle, java.lang.Class<? extends java.lang.Throwable>, java.lang.invoke.MethodHandle);
  public static java.lang.invoke.MethodHandle throwException(java.lang.Class<?>, java.lang.Class<? extends java.lang.Throwable>);
  public static java.lang.invoke.MethodHandle loop(java.lang.invoke.MethodHandle[]...);
  public static java.lang.invoke.MethodHandle whileLoop(java.lang.invoke.MethodHandle, java.lang.invoke.MethodHandle, java.lang.invoke.MethodHandle);
  public static java.lang.invoke.MethodHandle doWhileLoop(java.lang.invoke.MethodHandle, java.lang.invoke.MethodHandle, java.lang.invoke.MethodHandle);
  public static java.lang.invoke.MethodHandle countedLoop(java.lang.invoke.MethodHandle, java.lang.invoke.MethodHandle, java.lang.invoke.MethodHandle);
  public static java.lang.invoke.MethodHandle countedLoop(java.lang.invoke.MethodHandle, java.lang.invoke.MethodHandle, java.lang.invoke.MethodHandle, java.lang.invoke.MethodHandle);
  public static java.lang.invoke.MethodHandle iteratedLoop(java.lang.invoke.MethodHandle, java.lang.invoke.MethodHandle, java.lang.invoke.MethodHandle);
  static java.lang.invoke.MethodHandle swapArguments(java.lang.invoke.MethodHandle, int, int);
  public static java.lang.invoke.MethodHandle tryFinally(java.lang.invoke.MethodHandle, java.lang.invoke.MethodHandle);
  static {};
}
