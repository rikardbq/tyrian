Compiled from "MethodHandleImpl.java"
abstract class java.lang.invoke.MethodHandleImpl {
  static java.lang.invoke.MethodHandle[] FAKE_METHOD_HANDLE_INVOKE;
  static final int MAX_JVM_ARITY;
  static final byte NF_checkSpreadArgument;
  static final byte NF_guardWithCatch;
  static final byte NF_throwException;
  static final byte NF_tryFinally;
  static final byte NF_loop;
  static final byte NF_profileBoolean;
  static final byte NF_LIMIT;
  static final int MH_cast;
  static final int MH_selectAlternative;
  static final int MH_copyAsPrimitiveArray;
  static final int MH_fillNewTypedArray;
  static final int MH_fillNewArray;
  static final int MH_arrayIdentity;
  static final int MH_countedLoopPred;
  static final int MH_countedLoopStep;
  static final int MH_initIterator;
  static final int MH_iteratePred;
  static final int MH_iterateNext;
  static final int MH_Array_newInstance;
  static final int MH_LIMIT;
  static final boolean $assertionsDisabled;
  java.lang.invoke.MethodHandleImpl();
  static java.lang.invoke.MethodHandle makeArrayElementAccessor(java.lang.Class<?>, java.lang.invoke.MethodHandleImpl$ArrayAccess);
  static java.lang.InternalError unmatchedArrayAccess(java.lang.invoke.MethodHandleImpl$ArrayAccess);
  static java.lang.invoke.MethodHandle makePairwiseConvert(java.lang.invoke.MethodHandle, java.lang.invoke.MethodType, boolean, boolean);
  static java.lang.invoke.MethodHandle makePairwiseConvertByEditor(java.lang.invoke.MethodHandle, java.lang.invoke.MethodType, boolean, boolean);
  static java.lang.invoke.MethodHandle makePairwiseConvertIndirect(java.lang.invoke.MethodHandle, java.lang.invoke.MethodType, boolean, boolean);
  static java.lang.Object[] computeValueConversions(java.lang.invoke.MethodType, java.lang.invoke.MethodType, boolean, boolean);
  static java.lang.invoke.MethodHandle makePairwiseConvert(java.lang.invoke.MethodHandle, java.lang.invoke.MethodType, boolean);
  static java.lang.Object valueConversion(java.lang.Class<?>, java.lang.Class<?>, boolean, boolean);
  static java.lang.invoke.MethodHandle makeVarargsCollector(java.lang.invoke.MethodHandle, java.lang.Class<?>);
  static java.lang.invoke.MethodHandle makeSpreadArguments(java.lang.invoke.MethodHandle, java.lang.Class<?>, int, int);
  static void checkSpreadArgument(java.lang.Object, int);
  static java.lang.invoke.MethodHandle makeCollectArguments(java.lang.invoke.MethodHandle, java.lang.invoke.MethodHandle, int, boolean);
  static java.lang.invoke.MethodHandle selectAlternative(boolean, java.lang.invoke.MethodHandle, java.lang.invoke.MethodHandle);
  static boolean profileBoolean(boolean, int[]);
  static boolean isCompileConstant(java.lang.Object);
  static java.lang.invoke.MethodHandle makeGuardWithTest(java.lang.invoke.MethodHandle, java.lang.invoke.MethodHandle, java.lang.invoke.MethodHandle);
  static java.lang.invoke.MethodHandle profile(java.lang.invoke.MethodHandle);
  static java.lang.invoke.MethodHandle makeBlockInliningWrapper(java.lang.invoke.MethodHandle);
  static java.lang.invoke.LambdaForm makeGuardWithTestForm(java.lang.invoke.MethodType);
  static java.lang.invoke.MethodHandle makeGuardWithCatch(java.lang.invoke.MethodHandle, java.lang.Class<? extends java.lang.Throwable>, java.lang.invoke.MethodHandle);
  static java.lang.Object guardWithCatch(java.lang.invoke.MethodHandle, java.lang.Class<? extends java.lang.Throwable>, java.lang.invoke.MethodHandle, java.lang.Object...) throws java.lang.Throwable;
  static java.lang.invoke.MethodHandle throwException(java.lang.invoke.MethodType);
  static <T extends java.lang.Throwable> sun.invoke.empty.Empty throwException(T) throws T;
  static java.lang.invoke.MethodHandle fakeMethodHandleInvoke(java.lang.invoke.MemberName);
  static java.lang.invoke.MethodHandle fakeVarHandleInvoke(java.lang.invoke.MemberName);
  static java.lang.invoke.MethodHandle bindCaller(java.lang.invoke.MethodHandle, java.lang.Class<?>);
  static java.lang.invoke.MethodHandle makeWrappedMember(java.lang.invoke.MethodHandle, java.lang.invoke.MemberName, boolean);
  static java.lang.invoke.MethodHandle makeIntrinsic(java.lang.invoke.MethodHandle, java.lang.invoke.MethodHandleImpl$Intrinsic);
  static java.lang.invoke.MethodHandle makeIntrinsic(java.lang.invoke.MethodType, java.lang.invoke.LambdaForm, java.lang.invoke.MethodHandleImpl$Intrinsic);
  static java.lang.invoke.MethodHandle varargsArray(int);
  static <T> T[] identity(T[]);
  static java.lang.invoke.MethodHandle varargsArray(java.lang.Class<?>, int);
  static void assertSame(java.lang.Object, java.lang.Object);
  static java.lang.invoke.LambdaForm$NamedFunction getFunction(byte);
  static java.lang.invoke.MethodHandle makeLoop(java.lang.Class<?>, java.util.List<java.lang.Class<?>>, java.util.List<java.lang.invoke.MethodHandle>, java.util.List<java.lang.invoke.MethodHandle>, java.util.List<java.lang.invoke.MethodHandle>, java.util.List<java.lang.invoke.MethodHandle>);
  static java.lang.Object loop(java.lang.invoke.LambdaForm$BasicType[], java.lang.invoke.MethodHandleImpl$LoopClauses, java.lang.Object...) throws java.lang.Throwable;
  static boolean countedLoopPredicate(int, int);
  static int countedLoopStep(int, int);
  static java.util.Iterator<?> initIterator(java.lang.Iterable<?>);
  static boolean iteratePredicate(java.util.Iterator<?>);
  static java.lang.Object iterateNext(java.util.Iterator<?>);
  static java.lang.invoke.MethodHandle makeTryFinally(java.lang.invoke.MethodHandle, java.lang.invoke.MethodHandle, java.lang.Class<?>, java.util.List<java.lang.Class<?>>);
  static java.lang.Object tryFinally(java.lang.invoke.MethodHandle, java.lang.invoke.MethodHandle, java.lang.Object...) throws java.lang.Throwable;
  static java.lang.invoke.MethodHandle getConstantHandle(int);
  static {};
}
