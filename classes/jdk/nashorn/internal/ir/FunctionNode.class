Compiled from "FunctionNode.java"
public final class jdk.nashorn.internal.ir.FunctionNode extends jdk.nashorn.internal.ir.LexicalContextExpression implements jdk.nashorn.internal.ir.Flags<jdk.nashorn.internal.ir.FunctionNode>, jdk.nashorn.internal.ir.CompileUnitHolder {
  public static final jdk.nashorn.internal.codegen.types.Type FUNCTION_TYPE;
  public static final int IS_ANONYMOUS;
  public static final int IS_DECLARED;
  public static final int IS_STRICT;
  public static final int USES_ARGUMENTS;
  public static final int IS_SPLIT;
  public static final int HAS_EVAL;
  public static final int HAS_NESTED_EVAL;
  public static final int HAS_SCOPE_BLOCK;
  public static final int DEFINES_ARGUMENTS;
  public static final int USES_ANCESTOR_SCOPE;
  public static final int HAS_FUNCTION_DECLARATIONS;
  public static final int IS_DEOPTIMIZABLE;
  public static final int HAS_APPLY_TO_CALL_SPECIALIZATION;
  public static final int IS_PROGRAM;
  public static final int USES_SELF_SYMBOL;
  public static final int USES_THIS;
  public static final int IN_DYNAMIC_CONTEXT;
  public static final int NEEDS_CALLEE;
  public static final int IS_CACHED;
  public static final int ES6_HAS_DIRECT_SUPER;
  public static final int ES6_USES_SUPER;
  public static final int ES6_IS_METHOD;
  public static final int ES6_IS_CLASS_CONSTRUCTOR;
  public static final int ES6_IS_SUBCLASS_CONSTRUCTOR;
  public static final int ES6_IS_STRONG;
  public static final int ES6_USES_NEW_TARGET;
  public static final int HAS_EXPRESSION_BODY;
  public static final int HAS_ALL_VARS_IN_SCOPE;
  public static final int NEEDS_PARENT_SCOPE;
  public static final int DEBUG_PRINT_PARSE;
  public static final int DEBUG_PRINT_LOWER_PARSE;
  public static final int DEBUG_PRINT_AST;
  public static final int DEBUG_PRINT_LOWER_AST;
  public static final int DEBUG_PRINT_SYMBOLS;
  public static final int DEBUG_PROFILE;
  public static final int DEBUG_TRACE_ENTEREXIT;
  public static final int DEBUG_TRACE_MISSES;
  public static final int DEBUG_TRACE_VALUES;
  public static final int DEBUG_CALLSITE_FLAGS;
  public jdk.nashorn.internal.codegen.types.Type returnType;
  public jdk.nashorn.internal.ir.FunctionNode(jdk.nashorn.internal.runtime.Source, int, long, int, long, long, jdk.nashorn.internal.codegen.Namespace, jdk.nashorn.internal.ir.IdentNode, java.lang.String, java.util.List<jdk.nashorn.internal.ir.IdentNode>, java.util.Map<jdk.nashorn.internal.ir.IdentNode, jdk.nashorn.internal.ir.Expression>, jdk.nashorn.internal.ir.FunctionNode$Kind, int, jdk.nashorn.internal.ir.Block, java.lang.Object, jdk.nashorn.internal.ir.Module, int);
  public jdk.nashorn.internal.ir.Node accept(jdk.nashorn.internal.ir.LexicalContext, jdk.nashorn.internal.ir.visitor.NodeVisitor<? extends jdk.nashorn.internal.ir.LexicalContext>);
  public java.util.List<jdk.nashorn.internal.ir.IdentNode> visitParameters(jdk.nashorn.internal.ir.visitor.NodeVisitor<? extends jdk.nashorn.internal.ir.LexicalContext>);
  public int getCallSiteFlags();
  public jdk.nashorn.internal.runtime.Source getSource();
  public jdk.nashorn.internal.ir.FunctionNode initializeDeserialized(jdk.nashorn.internal.runtime.Source, jdk.nashorn.internal.codegen.Namespace);
  public int getId();
  public java.lang.String getSourceName();
  public static java.lang.String getSourceName(jdk.nashorn.internal.runtime.Source);
  public static int getDirectiveFlag(java.lang.String);
  public int getLineNumber();
  public java.lang.String uniqueName(java.lang.String);
  public void toString(java.lang.StringBuilder, boolean);
  public int getFlags();
  public boolean getFlag(int);
  public jdk.nashorn.internal.ir.FunctionNode setFlags(jdk.nashorn.internal.ir.LexicalContext, int);
  public jdk.nashorn.internal.ir.FunctionNode clearFlag(jdk.nashorn.internal.ir.LexicalContext, int);
  public jdk.nashorn.internal.ir.FunctionNode setFlag(jdk.nashorn.internal.ir.LexicalContext, int);
  public int getDebugFlags();
  public boolean getDebugFlag(int);
  public boolean isProgram();
  public boolean canBeDeoptimized();
  public boolean hasEval();
  public boolean hasNestedEval();
  public long getFirstToken();
  public boolean hasDeclaredFunctions();
  public boolean needsCallee();
  public boolean usesThis();
  public boolean hasApplyToCallSpecialization();
  public jdk.nashorn.internal.ir.IdentNode getIdent();
  public jdk.nashorn.internal.ir.Block getBody();
  public jdk.nashorn.internal.ir.FunctionNode setBody(jdk.nashorn.internal.ir.LexicalContext, jdk.nashorn.internal.ir.Block);
  public boolean isVarArg();
  public boolean inDynamicContext();
  public boolean needsDynamicScope();
  public jdk.nashorn.internal.ir.FunctionNode setInDynamicContext(jdk.nashorn.internal.ir.LexicalContext);
  public boolean needsArguments();
  public boolean needsParentScope();
  public jdk.nashorn.internal.ir.FunctionNode setThisProperties(jdk.nashorn.internal.ir.LexicalContext, int);
  public int getThisProperties();
  public boolean hasScopeBlock();
  public jdk.nashorn.internal.ir.FunctionNode$Kind getKind();
  public long getLastToken();
  public java.lang.Object getEndParserState();
  public java.lang.String getName();
  public jdk.nashorn.internal.ir.FunctionNode setName(jdk.nashorn.internal.ir.LexicalContext, java.lang.String);
  public boolean allVarsInScope();
  public boolean isSplit();
  public java.util.List<jdk.nashorn.internal.ir.IdentNode> getParameters();
  public java.util.Map<jdk.nashorn.internal.ir.IdentNode, jdk.nashorn.internal.ir.Expression> getParameterExpressions();
  public int getNumOfParams();
  public jdk.nashorn.internal.ir.IdentNode getParameter(int);
  public jdk.nashorn.internal.ir.FunctionNode setParameters(jdk.nashorn.internal.ir.LexicalContext, java.util.List<jdk.nashorn.internal.ir.IdentNode>);
  public boolean isDeclared();
  public boolean isAnonymous();
  public boolean usesSelfSymbol();
  public boolean isNamedFunctionExpression();
  public jdk.nashorn.internal.codegen.types.Type getType();
  public jdk.nashorn.internal.codegen.types.Type getWidestOperationType();
  public jdk.nashorn.internal.codegen.types.Type getReturnType();
  public jdk.nashorn.internal.ir.FunctionNode setReturnType(jdk.nashorn.internal.ir.LexicalContext, jdk.nashorn.internal.codegen.types.Type);
  public boolean isStrict();
  public boolean isCached();
  public jdk.nashorn.internal.ir.FunctionNode setCached(jdk.nashorn.internal.ir.LexicalContext);
  public boolean isStrong();
  public boolean isMethod();
  public boolean usesSuper();
  public boolean hasDirectSuper();
  public boolean isClassConstructor();
  public boolean isSubclassConstructor();
  public boolean usesNewTarget();
  public boolean isModule();
  public jdk.nashorn.internal.ir.Module getModule();
  public jdk.nashorn.internal.codegen.CompileUnit getCompileUnit();
  public jdk.nashorn.internal.ir.FunctionNode setCompileUnit(jdk.nashorn.internal.ir.LexicalContext, jdk.nashorn.internal.codegen.CompileUnit);
  public jdk.nashorn.internal.ir.Symbol compilerConstant(jdk.nashorn.internal.codegen.CompilerConstants);
  public java.lang.Class<?> getRootClass();
  public jdk.nashorn.internal.ir.FunctionNode setRootClass(jdk.nashorn.internal.ir.LexicalContext, java.lang.Class<?>);
  public jdk.nashorn.internal.ir.Node accept(jdk.nashorn.internal.ir.visitor.NodeVisitor);
  public jdk.nashorn.internal.ir.LexicalContextNode setFlags(jdk.nashorn.internal.ir.LexicalContext, int);
  public jdk.nashorn.internal.ir.LexicalContextNode setFlag(jdk.nashorn.internal.ir.LexicalContext, int);
  public jdk.nashorn.internal.ir.LexicalContextNode clearFlag(jdk.nashorn.internal.ir.LexicalContext, int);
  static {};
}
