Compiled from "MethodHandleFunctionality.java"
public interface jdk.nashorn.internal.lookup.MethodHandleFunctionality {
  public abstract java.lang.invoke.MethodHandle filterArguments(java.lang.invoke.MethodHandle, int, java.lang.invoke.MethodHandle...);
  public abstract java.lang.invoke.MethodHandle filterReturnValue(java.lang.invoke.MethodHandle, java.lang.invoke.MethodHandle);
  public abstract java.lang.invoke.MethodHandle guardWithTest(java.lang.invoke.MethodHandle, java.lang.invoke.MethodHandle, java.lang.invoke.MethodHandle);
  public abstract java.lang.invoke.MethodHandle insertArguments(java.lang.invoke.MethodHandle, int, java.lang.Object...);
  public abstract java.lang.invoke.MethodHandle dropArguments(java.lang.invoke.MethodHandle, int, java.lang.Class<?>...);
  public abstract java.lang.invoke.MethodHandle dropArguments(java.lang.invoke.MethodHandle, int, java.util.List<java.lang.Class<?>>);
  public abstract java.lang.invoke.MethodHandle foldArguments(java.lang.invoke.MethodHandle, java.lang.invoke.MethodHandle);
  public abstract java.lang.invoke.MethodHandle explicitCastArguments(java.lang.invoke.MethodHandle, java.lang.invoke.MethodType);
  public abstract java.lang.invoke.MethodHandle arrayElementGetter(java.lang.Class<?>);
  public abstract java.lang.invoke.MethodHandle arrayElementSetter(java.lang.Class<?>);
  public abstract java.lang.invoke.MethodHandle throwException(java.lang.Class<?>, java.lang.Class<? extends java.lang.Throwable>);
  public abstract java.lang.invoke.MethodHandle catchException(java.lang.invoke.MethodHandle, java.lang.Class<? extends java.lang.Throwable>, java.lang.invoke.MethodHandle);
  public abstract java.lang.invoke.MethodHandle constant(java.lang.Class<?>, java.lang.Object);
  public abstract java.lang.invoke.MethodHandle identity(java.lang.Class<?>);
  public abstract java.lang.invoke.MethodHandle asType(java.lang.invoke.MethodHandle, java.lang.invoke.MethodType);
  public abstract java.lang.invoke.MethodHandle asCollector(java.lang.invoke.MethodHandle, java.lang.Class<?>, int);
  public abstract java.lang.invoke.MethodHandle asSpreader(java.lang.invoke.MethodHandle, java.lang.Class<?>, int);
  public abstract java.lang.invoke.MethodHandle bindTo(java.lang.invoke.MethodHandle, java.lang.Object);
  public abstract java.lang.invoke.MethodHandle getter(java.lang.invoke.MethodHandles$Lookup, java.lang.Class<?>, java.lang.String, java.lang.Class<?>);
  public abstract java.lang.invoke.MethodHandle staticGetter(java.lang.invoke.MethodHandles$Lookup, java.lang.Class<?>, java.lang.String, java.lang.Class<?>);
  public abstract java.lang.invoke.MethodHandle setter(java.lang.invoke.MethodHandles$Lookup, java.lang.Class<?>, java.lang.String, java.lang.Class<?>);
  public abstract java.lang.invoke.MethodHandle staticSetter(java.lang.invoke.MethodHandles$Lookup, java.lang.Class<?>, java.lang.String, java.lang.Class<?>);
  public abstract java.lang.invoke.MethodHandle find(java.lang.reflect.Method);
  public abstract java.lang.invoke.MethodHandle findStatic(java.lang.invoke.MethodHandles$Lookup, java.lang.Class<?>, java.lang.String, java.lang.invoke.MethodType);
  public abstract java.lang.invoke.MethodHandle findVirtual(java.lang.invoke.MethodHandles$Lookup, java.lang.Class<?>, java.lang.String, java.lang.invoke.MethodType);
  public abstract java.lang.invoke.MethodHandle findSpecial(java.lang.invoke.MethodHandles$Lookup, java.lang.Class<?>, java.lang.String, java.lang.invoke.MethodType, java.lang.Class<?>);
  public abstract java.lang.invoke.SwitchPoint createSwitchPoint();
  public abstract java.lang.invoke.MethodHandle guardWithTest(java.lang.invoke.SwitchPoint, java.lang.invoke.MethodHandle, java.lang.invoke.MethodHandle);
  public abstract java.lang.invoke.MethodType type(java.lang.Class<?>, java.lang.Class<?>...);
}
