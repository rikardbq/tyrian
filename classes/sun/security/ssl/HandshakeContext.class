Compiled from "HandshakeContext.java"
abstract class sun.security.ssl.HandshakeContext implements sun.security.ssl.ConnectionContext {
  static final boolean allowUnsafeRenegotiation;
  static final boolean allowLegacyHelloMessages;
  java.util.LinkedHashMap<java.lang.Byte, sun.security.ssl.SSLConsumer> handshakeConsumers;
  final java.util.HashMap<java.lang.Byte, sun.security.ssl.HandshakeProducer> handshakeProducers;
  final sun.security.ssl.SSLContextImpl sslContext;
  final sun.security.ssl.TransportContext conContext;
  final sun.security.ssl.SSLConfiguration sslConfig;
  final java.util.List<sun.security.ssl.ProtocolVersion> activeProtocols;
  final java.util.List<sun.security.ssl.CipherSuite> activeCipherSuites;
  final java.security.AlgorithmConstraints algorithmConstraints;
  final sun.security.ssl.ProtocolVersion maximumActiveProtocol;
  final sun.security.ssl.HandshakeOutStream handshakeOutput;
  final sun.security.ssl.HandshakeHash handshakeHash;
  sun.security.ssl.SSLSessionImpl handshakeSession;
  boolean handshakeFinished;
  boolean kickstartMessageDelivered;
  boolean isResumption;
  sun.security.ssl.SSLSessionImpl resumingSession;
  final java.util.Queue<java.util.Map$Entry<java.lang.Byte, java.nio.ByteBuffer>> delegatedActions;
  volatile boolean taskDelegated;
  volatile java.lang.Exception delegatedThrown;
  sun.security.ssl.ProtocolVersion negotiatedProtocol;
  sun.security.ssl.CipherSuite negotiatedCipherSuite;
  final java.util.List<sun.security.ssl.SSLPossession> handshakePossessions;
  final java.util.List<sun.security.ssl.SSLCredentials> handshakeCredentials;
  sun.security.ssl.SSLKeyDerivation handshakeKeyDerivation;
  sun.security.ssl.SSLKeyExchange handshakeKeyExchange;
  javax.crypto.SecretKey baseReadSecret;
  javax.crypto.SecretKey baseWriteSecret;
  int clientHelloVersion;
  java.lang.String applicationProtocol;
  sun.security.ssl.RandomCookie clientHelloRandom;
  sun.security.ssl.RandomCookie serverHelloRandom;
  byte[] certRequestContext;
  final java.util.Map<sun.security.ssl.SSLExtension, sun.security.ssl.SSLExtension$SSLExtensionSpec> handshakeExtensions;
  int maxFragmentLength;
  java.util.List<sun.security.ssl.SignatureScheme> localSupportedSignAlgs;
  java.util.List<sun.security.ssl.SignatureScheme> peerRequestedSignatureSchemes;
  java.util.List<sun.security.ssl.SignatureScheme> peerRequestedCertSignSchemes;
  javax.security.auth.x500.X500Principal[] peerSupportedAuthorities;
  java.util.List<sun.security.ssl.SupportedGroupsExtension$NamedGroup> clientRequestedNamedGroups;
  sun.security.ssl.SupportedGroupsExtension$NamedGroup serverSelectedNamedGroup;
  java.util.List<javax.net.ssl.SNIServerName> requestedServerNames;
  javax.net.ssl.SNIServerName negotiatedServerName;
  boolean staplingActive;
  protected sun.security.ssl.HandshakeContext(sun.security.ssl.SSLContextImpl, sun.security.ssl.TransportContext) throws java.io.IOException;
  protected sun.security.ssl.HandshakeContext(sun.security.ssl.TransportContext);
  static byte getHandshakeType(sun.security.ssl.TransportContext, sun.security.ssl.Plaintext) throws java.io.IOException;
  void dispatch(byte, sun.security.ssl.Plaintext) throws java.io.IOException;
  void dispatch(byte, java.nio.ByteBuffer) throws java.io.IOException;
  abstract void kickstart() throws java.io.IOException;
  boolean isNegotiable(sun.security.ssl.CipherSuite);
  static final boolean isNegotiable(java.util.List<sun.security.ssl.CipherSuite>, sun.security.ssl.CipherSuite);
  static final boolean isNegotiable(java.util.List<sun.security.ssl.CipherSuite>, sun.security.ssl.ProtocolVersion, sun.security.ssl.CipherSuite);
  boolean isNegotiable(sun.security.ssl.ProtocolVersion);
  void setVersion(sun.security.ssl.ProtocolVersion);
  java.util.List<javax.net.ssl.SNIServerName> getRequestedServerNames();
  static {};
}
