Compiled from "Types.java"
public class com.sun.tools.javac.code.Types {
  protected static final com.sun.tools.javac.util.Context$Key<com.sun.tools.javac.code.Types> typesKey;
  final com.sun.tools.javac.code.Symtab syms;
  final com.sun.tools.javac.util.JavacMessages messages;
  final com.sun.tools.javac.util.Names names;
  final boolean allowObjectToPrimitiveCast;
  final boolean allowDefaultMethods;
  final boolean mapCapturesToBounds;
  final com.sun.tools.javac.comp.Check chk;
  final com.sun.tools.javac.comp.Enter enter;
  com.sun.tools.javac.util.JCDiagnostic$Factory diags;
  com.sun.tools.javac.util.List<com.sun.tools.javac.util.Warner> warnStack;
  final com.sun.tools.javac.util.Name capturedName;
  public final com.sun.tools.javac.util.Warner noWarnings;
  com.sun.tools.javac.code.Types$TypeRelation isSameTypeVisitor;
  java.util.Map<com.sun.tools.javac.code.Type, java.lang.Boolean> isDerivedRawCache;
  public com.sun.tools.javac.code.Types$CandidatesCache candidatesCache;
  com.sun.tools.javac.code.Types$TypeRelation hasSameArgs_strict;
  com.sun.tools.javac.code.Types$TypeRelation hasSameArgs_nonstrict;
  java.util.function.BiPredicate<com.sun.tools.javac.code.Type, com.sun.tools.javac.code.Type> basicClosureSkip;
  java.util.Set<com.sun.tools.javac.code.Types$TypePair> mergeCache;
  public static com.sun.tools.javac.code.Types instance(com.sun.tools.javac.util.Context);
  protected com.sun.tools.javac.code.Types(com.sun.tools.javac.util.Context);
  public com.sun.tools.javac.code.Type wildUpperBound(com.sun.tools.javac.code.Type);
  public com.sun.tools.javac.code.Type cvarUpperBound(com.sun.tools.javac.code.Type);
  public com.sun.tools.javac.code.Type wildLowerBound(com.sun.tools.javac.code.Type);
  public com.sun.tools.javac.code.Type cvarLowerBound(com.sun.tools.javac.code.Type);
  public com.sun.tools.javac.code.Type skipTypeVars(com.sun.tools.javac.code.Type, boolean);
  public com.sun.tools.javac.code.Type upward(com.sun.tools.javac.code.Type, com.sun.tools.javac.util.List<com.sun.tools.javac.code.Type>);
  public com.sun.tools.javac.util.List<com.sun.tools.javac.code.Type> captures(com.sun.tools.javac.code.Type);
  public boolean isUnbounded(com.sun.tools.javac.code.Type);
  public com.sun.tools.javac.code.Type asSub(com.sun.tools.javac.code.Type, com.sun.tools.javac.code.Symbol);
  public boolean isConvertible(com.sun.tools.javac.code.Type, com.sun.tools.javac.code.Type, com.sun.tools.javac.util.Warner);
  public boolean isConvertible(com.sun.tools.javac.code.Type, com.sun.tools.javac.code.Type);
  public com.sun.tools.javac.code.Symbol findDescriptorSymbol(com.sun.tools.javac.code.Symbol$TypeSymbol) throws com.sun.tools.javac.code.Types$FunctionDescriptorLookupError;
  public com.sun.tools.javac.code.Type findDescriptorType(com.sun.tools.javac.code.Type) throws com.sun.tools.javac.code.Types$FunctionDescriptorLookupError;
  public boolean isFunctionalInterface(com.sun.tools.javac.code.Symbol$TypeSymbol);
  public boolean isFunctionalInterface(com.sun.tools.javac.code.Type);
  public com.sun.tools.javac.code.Type removeWildcards(com.sun.tools.javac.code.Type);
  public com.sun.tools.javac.code.Symbol$ClassSymbol makeFunctionalInterfaceClass(com.sun.tools.javac.comp.Env<com.sun.tools.javac.comp.AttrContext>, com.sun.tools.javac.util.Name, com.sun.tools.javac.code.Type, long);
  public com.sun.tools.javac.util.List<com.sun.tools.javac.code.Symbol> functionalInterfaceBridges(com.sun.tools.javac.code.Symbol$TypeSymbol);
  public boolean isSubtypeUnchecked(com.sun.tools.javac.code.Type, com.sun.tools.javac.code.Type);
  public boolean isSubtypeUnchecked(com.sun.tools.javac.code.Type, com.sun.tools.javac.code.Type, com.sun.tools.javac.util.Warner);
  public final boolean isSubtype(com.sun.tools.javac.code.Type, com.sun.tools.javac.code.Type);
  public final boolean isSubtypeNoCapture(com.sun.tools.javac.code.Type, com.sun.tools.javac.code.Type);
  public boolean isSubtype(com.sun.tools.javac.code.Type, com.sun.tools.javac.code.Type, boolean);
  public boolean isSubtypeUnchecked(com.sun.tools.javac.code.Type, com.sun.tools.javac.util.List<com.sun.tools.javac.code.Type>, com.sun.tools.javac.util.Warner);
  public boolean isSubtypes(com.sun.tools.javac.util.List<com.sun.tools.javac.code.Type>, com.sun.tools.javac.util.List<com.sun.tools.javac.code.Type>);
  public boolean isSubtypesUnchecked(com.sun.tools.javac.util.List<com.sun.tools.javac.code.Type>, com.sun.tools.javac.util.List<com.sun.tools.javac.code.Type>, com.sun.tools.javac.util.Warner);
  public boolean isSuperType(com.sun.tools.javac.code.Type, com.sun.tools.javac.code.Type);
  public boolean isSameTypes(com.sun.tools.javac.util.List<com.sun.tools.javac.code.Type>, com.sun.tools.javac.util.List<com.sun.tools.javac.code.Type>);
  public boolean isSignaturePolymorphic(com.sun.tools.javac.code.Symbol$MethodSymbol);
  public boolean isSameType(com.sun.tools.javac.code.Type, com.sun.tools.javac.code.Type);
  public boolean containedBy(com.sun.tools.javac.code.Type, com.sun.tools.javac.code.Type);
  boolean containsType(com.sun.tools.javac.util.List<com.sun.tools.javac.code.Type>, com.sun.tools.javac.util.List<com.sun.tools.javac.code.Type>);
  public boolean containsType(com.sun.tools.javac.code.Type, com.sun.tools.javac.code.Type);
  public boolean isCaptureOf(com.sun.tools.javac.code.Type, com.sun.tools.javac.code.Type$WildcardType);
  public boolean isSameWildcard(com.sun.tools.javac.code.Type$WildcardType, com.sun.tools.javac.code.Type);
  public boolean containsTypeEquivalent(com.sun.tools.javac.util.List<com.sun.tools.javac.code.Type>, com.sun.tools.javac.util.List<com.sun.tools.javac.code.Type>);
  public boolean isCastable(com.sun.tools.javac.code.Type, com.sun.tools.javac.code.Type);
  public boolean isCastable(com.sun.tools.javac.code.Type, com.sun.tools.javac.code.Type, com.sun.tools.javac.util.Warner);
  public boolean disjointTypes(com.sun.tools.javac.util.List<com.sun.tools.javac.code.Type>, com.sun.tools.javac.util.List<com.sun.tools.javac.code.Type>);
  public boolean disjointType(com.sun.tools.javac.code.Type, com.sun.tools.javac.code.Type);
  public com.sun.tools.javac.util.List<com.sun.tools.javac.code.Type> cvarLowerBounds(com.sun.tools.javac.util.List<com.sun.tools.javac.code.Type>);
  public boolean notSoftSubtype(com.sun.tools.javac.code.Type, com.sun.tools.javac.code.Type);
  public boolean isReifiable(com.sun.tools.javac.code.Type);
  public boolean isArray(com.sun.tools.javac.code.Type);
  public com.sun.tools.javac.code.Type elemtype(com.sun.tools.javac.code.Type);
  public com.sun.tools.javac.code.Type elemtypeOrType(com.sun.tools.javac.code.Type);
  public int dimensions(com.sun.tools.javac.code.Type);
  public com.sun.tools.javac.code.Type$ArrayType makeArrayType(com.sun.tools.javac.code.Type);
  public com.sun.tools.javac.code.Type asSuper(com.sun.tools.javac.code.Type, com.sun.tools.javac.code.Symbol);
  public com.sun.tools.javac.code.Type asOuterSuper(com.sun.tools.javac.code.Type, com.sun.tools.javac.code.Symbol);
  public com.sun.tools.javac.code.Type asEnclosingSuper(com.sun.tools.javac.code.Type, com.sun.tools.javac.code.Symbol);
  public com.sun.tools.javac.code.Type memberType(com.sun.tools.javac.code.Type, com.sun.tools.javac.code.Symbol);
  public boolean isAssignable(com.sun.tools.javac.code.Type, com.sun.tools.javac.code.Type);
  public boolean isAssignable(com.sun.tools.javac.code.Type, com.sun.tools.javac.code.Type, com.sun.tools.javac.util.Warner);
  public com.sun.tools.javac.code.Type erasure(com.sun.tools.javac.code.Type);
  public com.sun.tools.javac.util.List<com.sun.tools.javac.code.Type> erasure(com.sun.tools.javac.util.List<com.sun.tools.javac.code.Type>);
  public com.sun.tools.javac.code.Type erasureRecursive(com.sun.tools.javac.code.Type);
  public com.sun.tools.javac.util.List<com.sun.tools.javac.code.Type> erasureRecursive(com.sun.tools.javac.util.List<com.sun.tools.javac.code.Type>);
  public com.sun.tools.javac.code.Type$IntersectionClassType makeIntersectionType(com.sun.tools.javac.util.List<com.sun.tools.javac.code.Type>);
  public com.sun.tools.javac.code.Type$IntersectionClassType makeIntersectionType(com.sun.tools.javac.util.List<com.sun.tools.javac.code.Type>, boolean);
  public com.sun.tools.javac.code.Type supertype(com.sun.tools.javac.code.Type);
  public com.sun.tools.javac.util.List<com.sun.tools.javac.code.Type> interfaces(com.sun.tools.javac.code.Type);
  public com.sun.tools.javac.util.List<com.sun.tools.javac.code.Type> directSupertypes(com.sun.tools.javac.code.Type);
  public boolean isDirectSuperInterface(com.sun.tools.javac.code.Symbol$TypeSymbol, com.sun.tools.javac.code.Symbol$TypeSymbol);
  public boolean isDerivedRaw(com.sun.tools.javac.code.Type);
  public boolean isDerivedRawInternal(com.sun.tools.javac.code.Type);
  public boolean isDerivedRaw(com.sun.tools.javac.util.List<com.sun.tools.javac.code.Type>);
  public void setBounds(com.sun.tools.javac.code.Type$TypeVar, com.sun.tools.javac.util.List<com.sun.tools.javac.code.Type>);
  public void setBounds(com.sun.tools.javac.code.Type$TypeVar, com.sun.tools.javac.util.List<com.sun.tools.javac.code.Type>, boolean);
  public com.sun.tools.javac.util.List<com.sun.tools.javac.code.Type> getBounds(com.sun.tools.javac.code.Type$TypeVar);
  public com.sun.tools.javac.code.Type classBound(com.sun.tools.javac.code.Type);
  public boolean isSubSignature(com.sun.tools.javac.code.Type, com.sun.tools.javac.code.Type);
  public boolean isSubSignature(com.sun.tools.javac.code.Type, com.sun.tools.javac.code.Type, boolean);
  public boolean overrideEquivalent(com.sun.tools.javac.code.Type, com.sun.tools.javac.code.Type);
  public boolean overridesObjectMethod(com.sun.tools.javac.code.Symbol$TypeSymbol, com.sun.tools.javac.code.Symbol);
  public java.util.Optional<com.sun.tools.javac.code.Symbol> mergeAbstracts(com.sun.tools.javac.util.List<com.sun.tools.javac.code.Symbol>, com.sun.tools.javac.code.Type, boolean);
  public com.sun.tools.javac.code.Symbol$MethodSymbol implementation(com.sun.tools.javac.code.Symbol$MethodSymbol, com.sun.tools.javac.code.Symbol$TypeSymbol, boolean, com.sun.tools.javac.util.Filter<com.sun.tools.javac.code.Symbol>);
  public com.sun.tools.javac.code.Scope$CompoundScope membersClosure(com.sun.tools.javac.code.Type, boolean);
  public com.sun.tools.javac.code.Symbol$MethodSymbol firstUnimplementedAbstract(com.sun.tools.javac.code.Symbol$ClassSymbol);
  public com.sun.tools.javac.util.List<com.sun.tools.javac.code.Symbol$MethodSymbol> interfaceCandidates(com.sun.tools.javac.code.Type, com.sun.tools.javac.code.Symbol$MethodSymbol);
  public com.sun.tools.javac.util.List<com.sun.tools.javac.code.Symbol$MethodSymbol> prune(com.sun.tools.javac.util.List<com.sun.tools.javac.code.Symbol$MethodSymbol>);
  public boolean hasSameArgs(com.sun.tools.javac.code.Type, com.sun.tools.javac.code.Type);
  public boolean hasSameArgs(com.sun.tools.javac.code.Type, com.sun.tools.javac.code.Type, boolean);
  public com.sun.tools.javac.util.List<com.sun.tools.javac.code.Type> subst(com.sun.tools.javac.util.List<com.sun.tools.javac.code.Type>, com.sun.tools.javac.util.List<com.sun.tools.javac.code.Type>, com.sun.tools.javac.util.List<com.sun.tools.javac.code.Type>);
  public com.sun.tools.javac.code.Type subst(com.sun.tools.javac.code.Type, com.sun.tools.javac.util.List<com.sun.tools.javac.code.Type>, com.sun.tools.javac.util.List<com.sun.tools.javac.code.Type>);
  public com.sun.tools.javac.util.List<com.sun.tools.javac.code.Type> substBounds(com.sun.tools.javac.util.List<com.sun.tools.javac.code.Type>, com.sun.tools.javac.util.List<com.sun.tools.javac.code.Type>, com.sun.tools.javac.util.List<com.sun.tools.javac.code.Type>);
  public com.sun.tools.javac.code.Type$TypeVar substBound(com.sun.tools.javac.code.Type$TypeVar, com.sun.tools.javac.util.List<com.sun.tools.javac.code.Type>, com.sun.tools.javac.util.List<com.sun.tools.javac.code.Type>);
  public boolean hasSameBounds(com.sun.tools.javac.code.Type$ForAll, com.sun.tools.javac.code.Type$ForAll);
  public com.sun.tools.javac.util.List<com.sun.tools.javac.code.Type> newInstances(com.sun.tools.javac.util.List<com.sun.tools.javac.code.Type>);
  public com.sun.tools.javac.code.Type createMethodTypeWithParameters(com.sun.tools.javac.code.Type, com.sun.tools.javac.util.List<com.sun.tools.javac.code.Type>);
  public com.sun.tools.javac.code.Type createMethodTypeWithThrown(com.sun.tools.javac.code.Type, com.sun.tools.javac.util.List<com.sun.tools.javac.code.Type>);
  public com.sun.tools.javac.code.Type createMethodTypeWithReturn(com.sun.tools.javac.code.Type, com.sun.tools.javac.code.Type);
  public com.sun.tools.javac.code.Type createErrorType(com.sun.tools.javac.code.Type);
  public com.sun.tools.javac.code.Type createErrorType(com.sun.tools.javac.code.Symbol$ClassSymbol, com.sun.tools.javac.code.Type);
  public com.sun.tools.javac.code.Type createErrorType(com.sun.tools.javac.util.Name, com.sun.tools.javac.code.Symbol$TypeSymbol, com.sun.tools.javac.code.Type);
  public int rank(com.sun.tools.javac.code.Type);
  public java.lang.String toString(com.sun.tools.javac.code.Type, java.util.Locale);
  public java.lang.String toString(com.sun.tools.javac.code.Symbol, java.util.Locale);
  public java.lang.String toString(com.sun.tools.javac.code.Type);
  public com.sun.tools.javac.util.List<com.sun.tools.javac.code.Type> closure(com.sun.tools.javac.code.Type);
  public java.util.stream.Collector<com.sun.tools.javac.code.Type, com.sun.tools.javac.code.Types$ClosureHolder, com.sun.tools.javac.util.List<com.sun.tools.javac.code.Type>> closureCollector(boolean, java.util.function.BiPredicate<com.sun.tools.javac.code.Type, com.sun.tools.javac.code.Type>);
  public com.sun.tools.javac.util.List<com.sun.tools.javac.code.Type> insert(com.sun.tools.javac.util.List<com.sun.tools.javac.code.Type>, com.sun.tools.javac.code.Type, java.util.function.BiPredicate<com.sun.tools.javac.code.Type, com.sun.tools.javac.code.Type>);
  public com.sun.tools.javac.util.List<com.sun.tools.javac.code.Type> insert(com.sun.tools.javac.util.List<com.sun.tools.javac.code.Type>, com.sun.tools.javac.code.Type);
  public com.sun.tools.javac.util.List<com.sun.tools.javac.code.Type> union(com.sun.tools.javac.util.List<com.sun.tools.javac.code.Type>, com.sun.tools.javac.util.List<com.sun.tools.javac.code.Type>, java.util.function.BiPredicate<com.sun.tools.javac.code.Type, com.sun.tools.javac.code.Type>);
  public com.sun.tools.javac.util.List<com.sun.tools.javac.code.Type> union(com.sun.tools.javac.util.List<com.sun.tools.javac.code.Type>, com.sun.tools.javac.util.List<com.sun.tools.javac.code.Type>);
  public com.sun.tools.javac.util.List<com.sun.tools.javac.code.Type> intersect(com.sun.tools.javac.util.List<com.sun.tools.javac.code.Type>, com.sun.tools.javac.util.List<com.sun.tools.javac.code.Type>);
  public com.sun.tools.javac.code.Type lub(com.sun.tools.javac.util.List<com.sun.tools.javac.code.Type>);
  public com.sun.tools.javac.code.Type lub(com.sun.tools.javac.code.Type...);
  com.sun.tools.javac.util.List<com.sun.tools.javac.code.Type> erasedSupertypes(com.sun.tools.javac.code.Type);
  public com.sun.tools.javac.code.Type glb(com.sun.tools.javac.util.List<com.sun.tools.javac.code.Type>);
  public com.sun.tools.javac.code.Type glb(com.sun.tools.javac.code.Type, com.sun.tools.javac.code.Type);
  public int hashCode(com.sun.tools.javac.code.Type);
  public int hashCode(com.sun.tools.javac.code.Type, boolean);
  public boolean resultSubtype(com.sun.tools.javac.code.Type, com.sun.tools.javac.code.Type, com.sun.tools.javac.util.Warner);
  public boolean returnTypeSubstitutable(com.sun.tools.javac.code.Type, com.sun.tools.javac.code.Type);
  public boolean returnTypeSubstitutable(com.sun.tools.javac.code.Type, com.sun.tools.javac.code.Type, com.sun.tools.javac.code.Type, com.sun.tools.javac.util.Warner);
  public boolean covariantReturnType(com.sun.tools.javac.code.Type, com.sun.tools.javac.code.Type, com.sun.tools.javac.util.Warner);
  public com.sun.tools.javac.code.Symbol$ClassSymbol boxedClass(com.sun.tools.javac.code.Type);
  public com.sun.tools.javac.code.Type boxedTypeOrType(com.sun.tools.javac.code.Type);
  public com.sun.tools.javac.code.Type unboxedType(com.sun.tools.javac.code.Type);
  public com.sun.tools.javac.code.Type unboxedTypeOrType(com.sun.tools.javac.code.Type);
  public com.sun.tools.javac.util.List<com.sun.tools.javac.code.Type> capture(com.sun.tools.javac.util.List<com.sun.tools.javac.code.Type>);
  public com.sun.tools.javac.code.Type capture(com.sun.tools.javac.code.Type);
  public com.sun.tools.javac.util.List<com.sun.tools.javac.code.Type> freshTypeVariables(com.sun.tools.javac.util.List<com.sun.tools.javac.code.Type>);
  public void adapt(com.sun.tools.javac.code.Type, com.sun.tools.javac.code.Type, com.sun.tools.javac.util.ListBuffer<com.sun.tools.javac.code.Type>, com.sun.tools.javac.util.ListBuffer<com.sun.tools.javac.code.Type>) throws com.sun.tools.javac.code.Types$AdaptFailure;
  public com.sun.tools.javac.code.Attribute$RetentionPolicy getRetention(com.sun.tools.javac.code.Attribute$Compound);
  public com.sun.tools.javac.code.Attribute$RetentionPolicy getRetention(com.sun.tools.javac.code.Symbol$TypeSymbol);
  public void newRound();
  static {};
}
