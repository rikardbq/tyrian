Compiled from "Check.java"
public class com.sun.tools.javac.comp.Check {
  protected static final com.sun.tools.javac.util.Context$Key<com.sun.tools.javac.comp.Check> checkKey;
  char syntheticNameChar;
  com.sun.tools.javac.comp.Check$CheckContext basicHandler;
  com.sun.tools.javac.code.Types$UnaryVisitor<java.lang.Boolean> isTypeArgErroneous;
  com.sun.tools.javac.util.Warner overrideWarner;
  public static com.sun.tools.javac.comp.Check instance(com.sun.tools.javac.util.Context);
  protected com.sun.tools.javac.comp.Check(com.sun.tools.javac.util.Context);
  com.sun.tools.javac.code.Lint setLint(com.sun.tools.javac.code.Lint);
  com.sun.tools.javac.code.Symbol$MethodSymbol setMethod(com.sun.tools.javac.code.Symbol$MethodSymbol);
  void warnDeprecated(com.sun.tools.javac.util.JCDiagnostic$DiagnosticPosition, com.sun.tools.javac.code.Symbol);
  public void warnUnchecked(com.sun.tools.javac.util.JCDiagnostic$DiagnosticPosition, com.sun.tools.javac.util.JCDiagnostic$Warning);
  void warnUnsafeVararg(com.sun.tools.javac.util.JCDiagnostic$DiagnosticPosition, com.sun.tools.javac.util.JCDiagnostic$Warning);
  public void warnStatic(com.sun.tools.javac.util.JCDiagnostic$DiagnosticPosition, com.sun.tools.javac.util.JCDiagnostic$Warning);
  void warnDivZero(com.sun.tools.javac.util.JCDiagnostic$DiagnosticPosition);
  public void reportDeferredDiagnostics();
  public com.sun.tools.javac.code.Type completionError(com.sun.tools.javac.util.JCDiagnostic$DiagnosticPosition, com.sun.tools.javac.code.Symbol$CompletionFailure);
  com.sun.tools.javac.code.Type typeTagError(com.sun.tools.javac.util.JCDiagnostic$DiagnosticPosition, com.sun.tools.javac.util.JCDiagnostic, java.lang.Object);
  void earlyRefError(com.sun.tools.javac.util.JCDiagnostic$DiagnosticPosition, com.sun.tools.javac.code.Symbol);
  void duplicateError(com.sun.tools.javac.util.JCDiagnostic$DiagnosticPosition, com.sun.tools.javac.code.Symbol);
  void varargsDuplicateError(com.sun.tools.javac.util.JCDiagnostic$DiagnosticPosition, com.sun.tools.javac.code.Symbol, com.sun.tools.javac.code.Symbol);
  void checkTransparentVar(com.sun.tools.javac.util.JCDiagnostic$DiagnosticPosition, com.sun.tools.javac.code.Symbol$VarSymbol, com.sun.tools.javac.code.Scope);
  void checkTransparentClass(com.sun.tools.javac.util.JCDiagnostic$DiagnosticPosition, com.sun.tools.javac.code.Symbol$ClassSymbol, com.sun.tools.javac.code.Scope);
  boolean checkUniqueClassName(com.sun.tools.javac.util.JCDiagnostic$DiagnosticPosition, com.sun.tools.javac.util.Name, com.sun.tools.javac.code.Scope);
  com.sun.tools.javac.util.Name localClassName(com.sun.tools.javac.code.Symbol$ClassSymbol);
  void clearLocalClassNameIndexes(com.sun.tools.javac.code.Symbol$ClassSymbol);
  public void newRound();
  public void putCompiled(com.sun.tools.javac.code.Symbol$ClassSymbol);
  public com.sun.tools.javac.code.Symbol$ClassSymbol getCompiled(com.sun.tools.javac.code.Symbol$ClassSymbol);
  public com.sun.tools.javac.code.Symbol$ClassSymbol getCompiled(com.sun.tools.javac.code.Symbol$ModuleSymbol, com.sun.tools.javac.util.Name);
  public void removeCompiled(com.sun.tools.javac.code.Symbol$ClassSymbol);
  public com.sun.tools.javac.code.Type checkType(com.sun.tools.javac.util.JCDiagnostic$DiagnosticPosition, com.sun.tools.javac.code.Type, com.sun.tools.javac.code.Type);
  com.sun.tools.javac.code.Type checkType(com.sun.tools.javac.util.JCDiagnostic$DiagnosticPosition, com.sun.tools.javac.code.Type, com.sun.tools.javac.code.Type, com.sun.tools.javac.comp.Check$CheckContext);
  com.sun.tools.javac.code.Type checkCastable(com.sun.tools.javac.util.JCDiagnostic$DiagnosticPosition, com.sun.tools.javac.code.Type, com.sun.tools.javac.code.Type);
  com.sun.tools.javac.code.Type checkCastable(com.sun.tools.javac.util.JCDiagnostic$DiagnosticPosition, com.sun.tools.javac.code.Type, com.sun.tools.javac.code.Type, com.sun.tools.javac.comp.Check$CheckContext);
  public void checkRedundantCast(com.sun.tools.javac.comp.Env<com.sun.tools.javac.comp.AttrContext>, com.sun.tools.javac.tree.JCTree$JCTypeCast);
  com.sun.tools.javac.code.Type checkNonVoid(com.sun.tools.javac.util.JCDiagnostic$DiagnosticPosition, com.sun.tools.javac.code.Type);
  com.sun.tools.javac.code.Type checkClassOrArrayType(com.sun.tools.javac.util.JCDiagnostic$DiagnosticPosition, com.sun.tools.javac.code.Type);
  com.sun.tools.javac.code.Type checkClassType(com.sun.tools.javac.util.JCDiagnostic$DiagnosticPosition, com.sun.tools.javac.code.Type);
  com.sun.tools.javac.code.Type checkConstructorRefType(com.sun.tools.javac.util.JCDiagnostic$DiagnosticPosition, com.sun.tools.javac.code.Type);
  com.sun.tools.javac.code.Type checkClassType(com.sun.tools.javac.util.JCDiagnostic$DiagnosticPosition, com.sun.tools.javac.code.Type, boolean);
  com.sun.tools.javac.code.Type checkRefType(com.sun.tools.javac.util.JCDiagnostic$DiagnosticPosition, com.sun.tools.javac.code.Type);
  com.sun.tools.javac.util.List<com.sun.tools.javac.code.Type> checkRefTypes(com.sun.tools.javac.util.List<com.sun.tools.javac.tree.JCTree$JCExpression>, com.sun.tools.javac.util.List<com.sun.tools.javac.code.Type>);
  com.sun.tools.javac.code.Type checkNullOrRefType(com.sun.tools.javac.util.JCDiagnostic$DiagnosticPosition, com.sun.tools.javac.code.Type);
  boolean checkDisjoint(com.sun.tools.javac.util.JCDiagnostic$DiagnosticPosition, long, long, long);
  com.sun.tools.javac.code.Type checkDiamond(com.sun.tools.javac.tree.JCTree$JCNewClass, com.sun.tools.javac.code.Type);
  com.sun.tools.javac.util.List<com.sun.tools.javac.code.Type> checkDiamondDenotable(com.sun.tools.javac.code.Type$ClassType);
  public boolean checkDenotable(com.sun.tools.javac.code.Type);
  void checkVarargsMethodDecl(com.sun.tools.javac.comp.Env<com.sun.tools.javac.comp.AttrContext>, com.sun.tools.javac.tree.JCTree$JCMethodDecl);
  com.sun.tools.javac.code.Type checkLocalVarType(com.sun.tools.javac.util.JCDiagnostic$DiagnosticPosition, com.sun.tools.javac.code.Type, com.sun.tools.javac.util.Name);
  com.sun.tools.javac.code.Type checkMethod(com.sun.tools.javac.code.Type, com.sun.tools.javac.code.Symbol, com.sun.tools.javac.comp.Env<com.sun.tools.javac.comp.AttrContext>, com.sun.tools.javac.util.List<com.sun.tools.javac.tree.JCTree$JCExpression>, com.sun.tools.javac.util.List<com.sun.tools.javac.code.Type>, boolean, com.sun.tools.javac.comp.InferenceContext);
  public boolean checkValidGenericType(com.sun.tools.javac.code.Type);
  boolean isTypeArgErroneous(com.sun.tools.javac.code.Type);
  long checkFlags(com.sun.tools.javac.util.JCDiagnostic$DiagnosticPosition, long, com.sun.tools.javac.code.Symbol, com.sun.tools.javac.tree.JCTree);
  void validate(com.sun.tools.javac.tree.JCTree, com.sun.tools.javac.comp.Env<com.sun.tools.javac.comp.AttrContext>);
  void validate(com.sun.tools.javac.tree.JCTree, com.sun.tools.javac.comp.Env<com.sun.tools.javac.comp.AttrContext>, boolean);
  void validate(com.sun.tools.javac.util.List<? extends com.sun.tools.javac.tree.JCTree>, com.sun.tools.javac.comp.Env<com.sun.tools.javac.comp.AttrContext>);
  void checkRaw(com.sun.tools.javac.tree.JCTree, com.sun.tools.javac.comp.Env<com.sun.tools.javac.comp.AttrContext>);
  boolean subset(com.sun.tools.javac.code.Type, com.sun.tools.javac.util.List<com.sun.tools.javac.code.Type>);
  boolean intersects(com.sun.tools.javac.code.Type, com.sun.tools.javac.util.List<com.sun.tools.javac.code.Type>);
  com.sun.tools.javac.util.List<com.sun.tools.javac.code.Type> incl(com.sun.tools.javac.code.Type, com.sun.tools.javac.util.List<com.sun.tools.javac.code.Type>);
  com.sun.tools.javac.util.List<com.sun.tools.javac.code.Type> excl(com.sun.tools.javac.code.Type, com.sun.tools.javac.util.List<com.sun.tools.javac.code.Type>);
  com.sun.tools.javac.util.List<com.sun.tools.javac.code.Type> union(com.sun.tools.javac.util.List<com.sun.tools.javac.code.Type>, com.sun.tools.javac.util.List<com.sun.tools.javac.code.Type>);
  com.sun.tools.javac.util.List<com.sun.tools.javac.code.Type> diff(com.sun.tools.javac.util.List<com.sun.tools.javac.code.Type>, com.sun.tools.javac.util.List<com.sun.tools.javac.code.Type>);
  public com.sun.tools.javac.util.List<com.sun.tools.javac.code.Type> intersect(com.sun.tools.javac.util.List<com.sun.tools.javac.code.Type>, com.sun.tools.javac.util.List<com.sun.tools.javac.code.Type>);
  boolean isUnchecked(com.sun.tools.javac.code.Symbol$ClassSymbol);
  boolean isUnchecked(com.sun.tools.javac.code.Type);
  boolean isChecked(com.sun.tools.javac.code.Type);
  boolean isUnchecked(com.sun.tools.javac.util.JCDiagnostic$DiagnosticPosition, com.sun.tools.javac.code.Type);
  boolean isHandled(com.sun.tools.javac.code.Type, com.sun.tools.javac.util.List<com.sun.tools.javac.code.Type>);
  com.sun.tools.javac.util.List<com.sun.tools.javac.code.Type> unhandled(com.sun.tools.javac.util.List<com.sun.tools.javac.code.Type>, com.sun.tools.javac.util.List<com.sun.tools.javac.code.Type>);
  static int protection(long);
  com.sun.tools.javac.util.JCDiagnostic$Fragment cannotOverride(com.sun.tools.javac.code.Symbol$MethodSymbol, com.sun.tools.javac.code.Symbol$MethodSymbol);
  com.sun.tools.javac.util.JCDiagnostic$Fragment uncheckedOverrides(com.sun.tools.javac.code.Symbol$MethodSymbol, com.sun.tools.javac.code.Symbol$MethodSymbol);
  com.sun.tools.javac.util.JCDiagnostic$Fragment varargsOverrides(com.sun.tools.javac.code.Symbol$MethodSymbol, com.sun.tools.javac.code.Symbol$MethodSymbol);
  void checkOverride(com.sun.tools.javac.tree.JCTree, com.sun.tools.javac.code.Symbol$MethodSymbol, com.sun.tools.javac.code.Symbol$MethodSymbol, com.sun.tools.javac.code.Symbol$ClassSymbol);
  public void checkCompatibleConcretes(com.sun.tools.javac.util.JCDiagnostic$DiagnosticPosition, com.sun.tools.javac.code.Type);
  public boolean checkCompatibleAbstracts(com.sun.tools.javac.util.JCDiagnostic$DiagnosticPosition, com.sun.tools.javac.code.Type, com.sun.tools.javac.code.Type, com.sun.tools.javac.code.Type);
  boolean checkCommonOverriderIn(com.sun.tools.javac.code.Symbol, com.sun.tools.javac.code.Symbol, com.sun.tools.javac.code.Type);
  void checkOverride(com.sun.tools.javac.comp.Env<com.sun.tools.javac.comp.AttrContext>, com.sun.tools.javac.tree.JCTree$JCMethodDecl, com.sun.tools.javac.code.Symbol$MethodSymbol);
  void checkOverride(com.sun.tools.javac.tree.JCTree, com.sun.tools.javac.code.Type, com.sun.tools.javac.code.Symbol$ClassSymbol, com.sun.tools.javac.code.Symbol$MethodSymbol);
  public void checkClassOverrideEqualsAndHashIfNeeded(com.sun.tools.javac.util.JCDiagnostic$DiagnosticPosition, com.sun.tools.javac.code.Symbol$ClassSymbol);
  public void checkModuleName(com.sun.tools.javac.tree.JCTree$JCModuleDecl);
  void checkAllDefined(com.sun.tools.javac.util.JCDiagnostic$DiagnosticPosition, com.sun.tools.javac.code.Symbol$ClassSymbol);
  void checkNonCyclicDecl(com.sun.tools.javac.tree.JCTree$JCClassDecl);
  void checkNonCyclic(com.sun.tools.javac.util.JCDiagnostic$DiagnosticPosition, com.sun.tools.javac.code.Type);
  void checkNonCyclic(com.sun.tools.javac.util.JCDiagnostic$DiagnosticPosition, com.sun.tools.javac.code.Type$TypeVar);
  void checkImplementations(com.sun.tools.javac.tree.JCTree$JCClassDecl);
  void checkImplementations(com.sun.tools.javac.tree.JCTree, com.sun.tools.javac.code.Symbol$ClassSymbol, com.sun.tools.javac.code.Symbol$ClassSymbol);
  void checkCompatibleSupertypes(com.sun.tools.javac.util.JCDiagnostic$DiagnosticPosition, com.sun.tools.javac.code.Type);
  void checkOverrideClashes(com.sun.tools.javac.util.JCDiagnostic$DiagnosticPosition, com.sun.tools.javac.code.Type, com.sun.tools.javac.code.Symbol$MethodSymbol);
  void checkHideClashes(com.sun.tools.javac.util.JCDiagnostic$DiagnosticPosition, com.sun.tools.javac.code.Type, com.sun.tools.javac.code.Symbol$MethodSymbol);
  void checkDefaultMethodClashes(com.sun.tools.javac.util.JCDiagnostic$DiagnosticPosition, com.sun.tools.javac.code.Type);
  void checkPotentiallyAmbiguousOverloads(com.sun.tools.javac.util.JCDiagnostic$DiagnosticPosition, com.sun.tools.javac.code.Type, com.sun.tools.javac.code.Symbol$MethodSymbol, com.sun.tools.javac.code.Symbol$MethodSymbol);
  void checkAccessFromSerializableElement(com.sun.tools.javac.tree.JCTree, boolean);
  void checkClassBounds(com.sun.tools.javac.util.JCDiagnostic$DiagnosticPosition, com.sun.tools.javac.code.Type);
  void checkClassBounds(com.sun.tools.javac.util.JCDiagnostic$DiagnosticPosition, java.util.Map<com.sun.tools.javac.code.Symbol$TypeSymbol, com.sun.tools.javac.code.Type>, com.sun.tools.javac.code.Type);
  void checkNotRepeated(com.sun.tools.javac.util.JCDiagnostic$DiagnosticPosition, com.sun.tools.javac.code.Type, java.util.Set<com.sun.tools.javac.code.Type>);
  void validateAnnotationTree(com.sun.tools.javac.tree.JCTree);
  void validateAnnotationType(com.sun.tools.javac.tree.JCTree);
  void validateAnnotationType(com.sun.tools.javac.util.JCDiagnostic$DiagnosticPosition, com.sun.tools.javac.code.Type);
  void validateAnnotationMethod(com.sun.tools.javac.util.JCDiagnostic$DiagnosticPosition, com.sun.tools.javac.code.Symbol$MethodSymbol);
  public void validateAnnotations(com.sun.tools.javac.util.List<com.sun.tools.javac.tree.JCTree$JCAnnotation>, com.sun.tools.javac.code.Symbol);
  public void validateTypeAnnotations(com.sun.tools.javac.util.List<com.sun.tools.javac.tree.JCTree$JCAnnotation>, boolean);
  public void validateTypeAnnotation(com.sun.tools.javac.tree.JCTree$JCAnnotation, boolean);
  public void validateRepeatable(com.sun.tools.javac.code.Symbol$TypeSymbol, com.sun.tools.javac.code.Attribute$Compound, com.sun.tools.javac.util.JCDiagnostic$DiagnosticPosition);
  boolean isOverrider(com.sun.tools.javac.code.Symbol);
  protected boolean isTypeAnnotation(com.sun.tools.javac.tree.JCTree$JCAnnotation, boolean);
  boolean isTypeAnnotation(com.sun.tools.javac.code.Attribute, boolean);
  boolean annotationApplicable(com.sun.tools.javac.tree.JCTree$JCAnnotation, com.sun.tools.javac.code.Symbol);
  com.sun.tools.javac.code.Attribute$Array getAttributeTargetAttribute(com.sun.tools.javac.code.Symbol$TypeSymbol);
  public boolean validateAnnotationDeferErrors(com.sun.tools.javac.tree.JCTree$JCAnnotation);
  boolean validateTargetAnnotationValue(com.sun.tools.javac.tree.JCTree$JCAnnotation);
  void checkDeprecatedAnnotation(com.sun.tools.javac.util.JCDiagnostic$DiagnosticPosition, com.sun.tools.javac.code.Symbol);
  void checkDeprecated(com.sun.tools.javac.util.JCDiagnostic$DiagnosticPosition, com.sun.tools.javac.code.Symbol, com.sun.tools.javac.code.Symbol);
  void checkSunAPI(com.sun.tools.javac.util.JCDiagnostic$DiagnosticPosition, com.sun.tools.javac.code.Symbol);
  void checkProfile(com.sun.tools.javac.util.JCDiagnostic$DiagnosticPosition, com.sun.tools.javac.code.Symbol);
  void checkNonCyclicElements(com.sun.tools.javac.tree.JCTree$JCClassDecl);
  void checkNonCyclicElementsInternal(com.sun.tools.javac.util.JCDiagnostic$DiagnosticPosition, com.sun.tools.javac.code.Symbol$TypeSymbol);
  void checkAnnotationResType(com.sun.tools.javac.util.JCDiagnostic$DiagnosticPosition, com.sun.tools.javac.code.Type);
  void checkCyclicConstructors(com.sun.tools.javac.tree.JCTree$JCClassDecl);
  void checkDivZero(com.sun.tools.javac.util.JCDiagnostic$DiagnosticPosition, com.sun.tools.javac.code.Symbol, com.sun.tools.javac.code.Type);
  void checkEmptyIf(com.sun.tools.javac.tree.JCTree$JCIf);
  boolean checkUnique(com.sun.tools.javac.util.JCDiagnostic$DiagnosticPosition, com.sun.tools.javac.code.Symbol, com.sun.tools.javac.code.Scope);
  void duplicateErasureError(com.sun.tools.javac.util.JCDiagnostic$DiagnosticPosition, com.sun.tools.javac.code.Symbol, com.sun.tools.javac.code.Symbol);
  void checkImportsUnique(com.sun.tools.javac.tree.JCTree$JCCompilationUnit);
  public void checkCanonical(com.sun.tools.javac.tree.JCTree);
  void checkForBadAuxiliaryClassAccess(com.sun.tools.javac.util.JCDiagnostic$DiagnosticPosition, com.sun.tools.javac.comp.Env<com.sun.tools.javac.comp.AttrContext>, com.sun.tools.javac.code.Symbol$ClassSymbol);
  public com.sun.tools.javac.util.Warner castWarner(com.sun.tools.javac.util.JCDiagnostic$DiagnosticPosition, com.sun.tools.javac.code.Type, com.sun.tools.javac.code.Type);
  public com.sun.tools.javac.util.Warner convertWarner(com.sun.tools.javac.util.JCDiagnostic$DiagnosticPosition, com.sun.tools.javac.code.Type, com.sun.tools.javac.code.Type);
  public void checkFunctionalInterface(com.sun.tools.javac.tree.JCTree$JCClassDecl, com.sun.tools.javac.code.Symbol$ClassSymbol);
  public void checkImportsResolvable(com.sun.tools.javac.tree.JCTree$JCCompilationUnit);
  public void checkImportedPackagesObservable(com.sun.tools.javac.tree.JCTree$JCCompilationUnit);
  public boolean importAccessible(com.sun.tools.javac.code.Symbol, com.sun.tools.javac.code.Symbol$PackageSymbol);
  public void checkLeaksNotAccessible(com.sun.tools.javac.comp.Env<com.sun.tools.javac.comp.AttrContext>, com.sun.tools.javac.tree.JCTree$JCClassDecl);
  void checkModuleExists(com.sun.tools.javac.util.JCDiagnostic$DiagnosticPosition, com.sun.tools.javac.code.Symbol$ModuleSymbol);
  void checkPackageExistsForOpens(com.sun.tools.javac.util.JCDiagnostic$DiagnosticPosition, com.sun.tools.javac.code.Symbol$PackageSymbol);
  void checkModuleRequires(com.sun.tools.javac.util.JCDiagnostic$DiagnosticPosition, com.sun.tools.javac.code.Directive$RequiresDirective);
  static {};
}
